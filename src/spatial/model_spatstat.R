# Shared functions for the different spatstat models

#' Read cell location, cell type and annotation from file into a spatstat ppp object.
#'
#' @description Reads cell location and cell type from a RDS file generated by the
#' `call_cell_types.R` script and the annotation generated by the `load_annoation.R` script.
#' All cells are expected to fall in the annotation area.
#'
#' @param objects_fn RDS with a data frame with cell location (x, y) and called cell type columns.
#' @param annotation_fn Annotation area in well-known binary (WKB) format. Coordinates are expected
#'     in pixels and are multiplied by the pixel_size global variable to match the coordinates of
#'     the cells.
#'
#' @return A spatstat::ppp object with the cells as points marked by cell_type and the annotation
#'    area as the observation window.
#'
#' @examples
#' cells <- read_cells('data/vectra/processed/objects/T09-22827_MPIF26_batch4.Rds',
#'                     'data/vectra/interim/annotations/T09-22827_MPIF26_batch4_tumor.wkb')
read_cells <- function(objects_fn, annotation_fn) {
  objects <- readRDS(objects_fn)
  max_size <- 1e6
  annot_bin <- readBin(annotation_fn, 'raw', max_size)
  if (length(annot_bin) == max_size) {
    stop('Buffer not large enough') # Fixme: loop until everything has been read
  }
  ow <- spatstat.geom::as.owin(sf::st_as_sfc(annot_bin) * pixel_size)
  spatstat.geom::unitname(ow) <- unitname
  ow <- spatstat.geom::dilation(ow, pixel_size) # Otherwise not all cells lie exactly within
  samples_known_points_outside_window <- c(
    'T21-60592_MPIF27_batch3', 
    'T20-62178_MPIF27_batch7') # FIXME: This sample is missing an area in the annotation
  if (any(stringr::str_detect(objects_fn, samples_known_points_outside_window))) {
    objects <- objects[spatstat.geom::inside.owin(objects$x, objects$y, ow), ]
  }
  objects_pp <- spatstat.geom::ppp(x=objects$x, y=objects$y, marks=objects$cell_type, window = ow)
  objects_pp
}

#' Run a spatial statistic function adjusted for simultation results.
#'
#' @description   Calculates a spatial statistic in `fun` for the data in `cells` and for `nsim`
#'   simulated datasets generated by `simulation`. The mean of the simulation results is substracted
#'   from the and reported in the `delta_estimate` column of the result.
#' @param cells       A spatstat::ppp object with cells in an observation window.
#' @param nsim        Number of simultations to run.
#' @param fun         A function that calculates the spatial statistic. For example compute_L in
#'   src/spatial/model_l.R.
#' @param simultation A list containing a function that generated simulated spatial point
#'                      patterns. For example simple_poisson_null.
#' @param ...         Optional extra arguments passed to `fun`.
#' @param .progress_bar If not null, this progress bar is updated with a tick for every evaluation
#'   of fun, that is nsim + 1 times.
#' @return A data frame, with an observed_estimate column containing the spatial statistic returned
#'   by fun, a delta_estimate column which has the mean of the estimates in the simulations
#'   subtracted, and a model containing a printable name describing fun. Number of rows is
#'   determined by what is returned by `fun`, for example, L measures are for different radii.
#' @examples
#' cells <- read_cells('data/vectra/processed/objects/T09-22827_MPIF26_batch4.Rds',
#'                     'data/vectra/interim/annotations/T09-22827_MPIF26_batch4_tumor.wkb')
#' with_simulation(cells, 1000, compute_L, simple_poisson_null, radii = 0.1)
with_simulation <- function(cells, nsim, fun, simulation, ..., .progress_bar=NULL) {
  progress_bar <- .progress_bar
  observed_res <- fun(cells, ...)
  if (!is.null(progress_bar)) progress_bar$tick()
  null_res <- purrr::map_dfr(1:nsim, function (isim)  {
      cells_sim <- simulation$fun(cells, ...)
      res <- fun(cells_sim, ...)
      if (!is.null(progress_bar)) progress_bar$tick()
      res
    }, .id='simulation') %>%
    group_by(across(-c(simulation, estimate))) %>%
    summarise(null_estimate = mean(estimate, na.rm=T), .groups = 'drop')
  left_join(observed_res, null_res, by = setdiff(colnames(observed_res), 'estimate')) %>%
    mutate(
      observed_estimate = estimate,
      delta_estimate = estimate - null_estimate,
      model = simulation$name(...)) %>%
    select(-estimate)
}


#' Null model generating cell locations from a Poisson distribution with the same density as the
#' observed data. All cells are randomized.
simple_poisson_null <- list(
  fun = function(cells, ...) {
    n_cells <- spatstat.geom::npoints(cells)
    ow <- spatstat.geom::as.owin(cells)
    withCallingHandlers(
      spatstat.core::rpoint(n_cells, win=ow),
      # Ignore warning of creating a large number of points
      warning = function (cond) {
        if (stringr::str_starts(cond$message, "Attempting to generate ")) {
          invokeRestart("muffleWarning")
        }
    })
  },
  name = function (...) 'Poisson')

#' Null model generating cell locations from a Poisson distribution with the same density as the
#' observed data for the cells whose mark equals `resample_mark`. Other cells are not randomized
#' and just copied from the observed data.
subset_poisson_null <- list(
  fun = function(cells, resample_mark, ...) {
    sample_cells <- subset(cells, marks == resample_mark)
    other_cells <- subset(cells, marks != resample_mark)
    n_cells <- spatstat.geom::npoints(sample_cells)
    ow <- spatstat.geom::as.owin(cells)
    simulated_cells <- withCallingHandlers(
      spatstat.core::rpoint(n_cells, win=ow),
      # Ignore warning of creating a large number of points
      warning = function (cond) {
        if (stringr::str_starts(cond$message, "Attempting to generate ")) {
          invokeRestart("muffleWarning")
        }
    })
    spatstat.geom::marks(simulated_cells) <- factor(
      resample_mark,
      levels = levels(spatstat.geom::marks(cells)))
    spatstat.geom::superimpose(simulated_cells, other_cells)
  },
  name = function(resample_mark, ...) {paste0("Poisson (", resample_mark, ")")})
