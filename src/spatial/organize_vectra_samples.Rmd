---
title: "Organize Vectra samples"
author: "Kat Moore and Tycho Bismeijer"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 4
    df_print: paged
    highlight: kate
params:
    metadata: ""
    batch_info: ""
    example_halo_archive: ""
    vectra_dir: ""
    out: ""
---

Here we discover the Vectra data exported from Halo in the `data/vectra` directory.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r lib, message=FALSE}
library(here)
library(lubridate)
library(tidyverse)
```

## Overview

In Nov 2021, we went from having a single exported batch to work with, to having all batches available.

```{r}
batches <- list.files(here(params$vectra_dir, 'halo'), pattern = "Batch")
print(batches)
```

There are two panels in each batch. The markers are as follows:

MPIF26 = CD3_CD20_CD27_FoxP3_PanCK
MPIF27 = CD3_CD8_CD138_CD20_PanCK

We cross-reference these samples with the list of known failed stainings later on.

## Sample Annotation

All samples now have a T-number.

```{r}
sample_annotation <- readxl::read_excel(here(params$metadata), 1)
head(sample_annotation)
```

## Directory structure

For every sample, the data is in a dated sub-directory.

```{r}
list.files(here(params$example_halo_archive))
```

Basic stats are in `summary_results.csv`.

```{r}
read_csv(here(params$example_halo_archive, "summary_results.csv"))
```

Full results are in an `object_results.csv` file.

```{r}
object_results_files <- list.files(here(params$example_halo_archive), "*.object_results.csv")
stopifnot(length(object_results_files) == 1)
read_csv(here(params$example_halo_archive, object_results_files[1])) %>% head()
```

The image segmentations are in the Images directory with a .annotations extension: these are xml
files. Unclear what the difference is between the two annotations files.

```{r}
list.files(here(params$example_halo_archive, "Images"))
```

## Failed and missing samples

A number of analyses failed.

```{r}
sample_annotation %>%
  filter(sample_type == 'slide' & Included == 0) %>%
  select(sample_ID, experimental_platform, patient_ID, batch_Leuven, batch_HALO, comments)
```

*TODO:  Ensure that the samples present in each batch are identical when the numbers are equal, and
print the discrepancy when they are not.*


### Duplicates

Some patients evidently provided more than one tissue block.

```{r}
patients_with_duplicates <- sample_annotation %>%
    filter(sample_type == 'slide', Included == 1) %>%
    group_by(patient_ID, experimental_platform) %>%
    count() %>%
    filter(n > 1) %>%
    `$`('patient_ID') %>%
    unique()

sample_annotation %>%
  filter(
    sample_type == 'slide',
    patient_ID %in% patients_with_duplicates) %>%
  arrange(patient_ID) %>%
  select(patient_ID, sample_ID, experimental_platform)
```

## File location dictionary

### Object results

The data is located in `r params$vectra_dir`/halo in directories, with the first directory
identifying the batch starting with batch, then a directory with the panel name, then a directory
with the t-number.


```{r}
object_files <- tibble(
  object_path = list.files(
    here(params$vectra_dir, 'halo', batches),
    recursive = T, full.names = T, pattern = ".object_results.csv"
  )) %>%
  #Extract the t_number, batch and panel from the object results
  mutate(
    split_object_path=fs::path_split(object_path),
    HALO_batch = map_chr(split_object_path, ~ .[[length(.)-4]]),
    panel = map_chr(split_object_path, ~ .[[length(.)-3]]),
    t_number = map_chr(split_object_path, ~ .[[length(.)-2]])) %>%
  select(-split_object_path) %>%
  relocate(object_path, .after = everything()) %>%
  relocate(t_number, .before = everything()) %>%
  arrange(t_number)

head(object_files)
```

The number of sample-panel combinations with an object file is `r nrow(object_files)` for
`r length(unique(object_files$t_number))` samples.

Sample-panel combinations for which we did not find an object file:

```{r}
anti_join(
  filter(sample_annotation, sample_type == 'slide' & Included == 1),
  object_files,
  by = c(sample_ID = 't_number', experimental_platform = 'panel'))
```

and those for which we have a file, but don't expect it:

```{r}
anti_join(
  object_files,
  filter(sample_annotation, sample_type == 'slide' & Included == 1),
  by=c(t_number = 'sample_ID', panel = 'experimental_platform'))
```

and check for doubles

```{r}
object_files %>%
  group_by(t_number, panel) %>%
  count() %>%
  filter(n > 1) %>%
  right_join(object_files, by=c('t_number', 'panel'))
```


### Summary results

This file is always called `summary_results.csv`, regardless of the sample it belongs to.

```{r, eval=F}
temp <- tibble(
  summary_path = list.files(
    file.path(mainDir, batches), #Excluding the old Leuven export
    recursive = T, full.names = T, pattern = "summary_results.csv"
  )
) %>%
  #Extract the t_number, batch and panel from the object results
  separate(summary_path,
           into=c(NA,NA,NA,NA,NA,NA,"batch","panel",
                  "t_number", "Halo_time", "summary_file"),sep="/", remove = F) %>%
  relocate(summary_path, .after = everything()) %>%
  relocate(t_number, .before = everything()) %>%
  arrange(t_number) %>%
  #Discard redundancies
  select(-batch, -summary_file)

#Pre-emptively detect problems with joining
stopifnot(all(sort(temp$t_number) == sort(filedict$t_number)))

#Join by all three unless you want many problems
filedict <- left_join(filedict, temp, by=c("t_number", "panel", "Halo_time"))
rm(temp)
```

```{r, eval=F}
print(paste("Number of samples", nrow(filedict)))
```

### Annotations files

The first batch had multiple annotation files per sample, but it looks like that's no longer the case.

The number of annotation files found indicates that there are irregularities.

```{r, eval=F}
temp <- tibble(
  annotation_path = list.files(
    file.path(mainDir, batches), #Excluding the old Leuven export
    recursive = T, full.names = T, pattern = "annotations"
  )
) %>%
  #Extract the t_number, batch and panel from the object results
  separate(annotation_path,
           into=c(NA,NA,NA,NA,NA,NA,"batch","panel",
                  "t_number", "Halo_time", NA, "annotation_file"),sep="/", remove = F) %>%
  relocate(annotation_path, .after = everything()) %>%
  relocate(t_number, .before = everything()) %>%
  arrange(t_number)

print(paste("Number of samples:", nrow(filedict)))
print(paste("Number of annotation files:", nrow(temp)))
```

Count annotation files by sample TODO

```{r, eval=F}
anno_inv <- temp %>%
  select(-Halo_time, -annotation_path) %>%
  pivot_wider(names_from = panel, values_from = annotation_file,
              values_fn = list) %>%
  #Somewhat cumbersome method of using filter with listcols
  filter(map_lgl(MPIF26, ~ .x %>%
                   length !=1) |
           map_lgl(MPIF27, ~ .x %>%
                   length !=1)) %>%
  mutate(MPIF26_present = map_lgl(MPIF26, ~ .x %>%
                   length >0),
         MPIF27_present = map_lgl(MPIF27, ~ .x %>%
                   length >0)
)

head(anno_inv)
```

For those samples missing annotation files: check if they're not already in the missing sample list.

```{r, eval=F}
stopifnot(nrow(
  filter(anno_inv, MPIF26_present == F | MPIF27_present == F)$t_number 
  %in% missing_samples$t_number
  ) == 0
)
```

Now figure out what is going on with the annotation file duplicates and nomenclature.

```{r, eval=F}
annos_by_batch <- temp %>%
  group_by(t_number, batch, panel) %>%
  summarise(annos_per_sample = n(), .groups = "drop") %>%
  #Exclude this one, it has two results folders in MPIF26
  filter(t_number != "T09-22827") %>%
  #Check to see whether the number of annotation files is consistent within-batch
  group_by(batch, panel, annos_per_sample) %>%
  count() %>%
  pivot_wider(names_from = panel, values_from = n, values_fill = 0)

annos_by_batch
```

Most batches have either 1 or 2 annotation files per sample, but there are exceptions to each.

Look at some outliers. It appears that the duplicate annotation files have the same file name, but one includes a job id.

```{r, eval=F}
temp %>%
  filter(batch == "Batch 5" & panel == "MPIF26") %>%
  filter(duplicated(t_number) | duplicated(t_number, fromLast=T))
```

For now, just track both annotation files, where applicable.

```{r, eval=F}
temp <- temp %>%
  mutate(annotation_type = ifelse(str_detect(annotation_file, "job"),
                                  "anno_job", "anno"), .before = batch) %>%
  select(-annotation_file) %>%
  pivot_wider(names_from = annotation_type, values_from = annotation_path) %>%
  rename(anno_path = anno, anno_job_path = anno_job)

#Please be true
stopifnot(all(sort(temp$t_number)==sort(filedict$t_number)))
```

Make sure we didn't gain any rows.

```{r, eval=F}
print(paste("Number of samples:", nrow(filedict)))
filedict <- left_join(filedict, temp, by = c("t_number", "batch", "panel", "Halo_time"))
print(paste("Number of samples:", nrow(filedict)))
```

All samples have at least one annotation file that does not have a job id in the filename. Some samples lack the second annotation file that includes a job id.

```{r, eval=F}
filedict %>%
  filter(is.na(anno_path)) %>%
  nrow()

filedict %>%
  filter(is.na(anno_job_path)) %>%
  nrow()
```

## Link to RNA data

Link with RNAseq IDs and study_group etc. Note: the molecular subtypes as listed here are based on the clinical classification from Leuven. Also, some samples were later removed from the RNAseq analysis for QC reasons, and some of the patient refs among the Vectra data were not included among the RNAseq data.

```{r, eval=F}
rna_meta <- read_tsv(here("data/metadata/01_sample_annot.tsv")) %>%
  select(sample_ref, patient_ref, sample_name, study_group, PPBC, country,
         clin_subtype = molecular_subtype,
         stage=stage_short, grade, TIL_percent = TILprecent, age = age_diagnosis,
         overall_survival, distant_recurrence, months_of_followup,
         months_involution_breastfeeding, breastfeeding_months)
  
combi_meta <- left_join(meta, rna_meta,
                          by = c("extern_number" = "sample_ref")) %>%
  distinct() %>%
  #Discard excess columns
  select(-annotations:-exported, -comments2, -comments3)

stopifnot(nrow(combi_meta) == nrow(meta))
```

For those that we could not find: check to see if the external number matches the patient ref instead of the sample ref.

```{r, eval=F}
#Split those we couldn't find off from the metadata
no_outcome <- combi_meta %>%
  filter(is.na(study_group)) %>%
  select(-patient_ref:-breastfeeding_months) 

print(paste("Samples lacking clinical data:",
            length(unique(no_outcome$extern_number))))

no_outcome <- no_outcome %>%
  left_join(., rna_meta,
            by = c("extern_number" = "patient_ref")) %>%
  #When joining by patient ref, duplicates can arise because some 
  #patients provided multiple RNA samples
  distinct()

print(paste("Samples lacking clinical data:",
            length(unique(filter(no_outcome, is.na(study_group))$extern_number))))
```

As a last measure to find clinical data related to these samples: check the original raw metadata file provided by Hanne. We did not find them.

```{r, eval=F}
raw_rna_meta <- readxl::read_excel(here("data/external/Hercoderingslijst_v09032020_KM.xlsx"),
                   sheet = "Recoding Book_v09032020_Overall") %>%
  select(patient_ref = `NEW REF`, 
         old_ref = `OLD REF`,
         study_group = `Study Group...6`#,
         # country = `Country of Diagnosis`,
         # clin_subtype = `Molecular Subtype`,
         # stage=`Stage (1,2,3,4)`,
         # grade=`Grade`, 
         # TIL_percent = `TIL %`,
         # age = `Age of Diagnosis`,
         # #1 = death
         # overall_survival = `Overall Survival (OS)`,
         # #1 = recurrence
         # distant_recurrence = `Distant Recurrence`,
         # months_of_followup = `Time of FU (Months)`,
         # months_involution_breastfeeding = Months_Involution_Breastfeeding,
         # breastfeeding_months = `Months breastfeeding for cancer-related pregnancy`
         )

filter(no_outcome, is.na(study_group))$extern_number %in% raw_rna_meta$patient_ref
filter(no_outcome, is.na(study_group))$extern_number %in% raw_rna_meta$old_ref

```

Rejoin the samples we were able to repair.

```{r, eval=F}
#Remove the old empty rows
combi_meta <- combi_meta %>%
  filter(!is.na(study_group))

stopifnot(all(!no_outcome$extern_number %in% combi_meta$extern_number))
#Add the repaired rows
combi_meta <- bind_rows(combi_meta, no_outcome)
stopifnot(all(
  sort(combi_meta$extern_number) == sort(meta$extern_number)
))
```

### Samples absent in RNAseq

Identify remaining patient refs that cannot be found in the RNAseq data.

```{r, eval=F}
combi_meta %>%
  filter(is.na(study_group)) %>%
  select(extern_number, t_number) %>% distinct()
```

## Batches

The batch indicated by the file name is not the same as the staining batch, which is called "extern" in the metadata.

```{r, eval=F}
filedict %>%
  select(t_number, panel, file_batch = batch) %>%
  left_join(., select(combi_meta, t_number, staining, extern_batch, batch_in_halo),
            by=c("t_number", "panel"="staining")) %>%
  select(t_number, file_batch:batch_in_halo) %>%
  distinct() %>%
  group_by(file_batch, extern_batch, batch_in_halo) %>%
  count()
```

We are not interested in formally correcting for batch effects right now, so this needn't be altered in the symlinks.

## Create symlinks

Create directory structure.

```{r, eval=F}
symdir <- here("data/vectra/raw")
dir.create(symdir, showWarnings = F)

dir.create(file.path(symdir, "annotations"), showWarnings = F)
dir.create(here(symdir, "annotations", "job_annotations"), showWarnings = F)
dir.create(file.path(symdir, "objects"), showWarnings = F)
dir.create(file.path(symdir, "summary"), showWarnings = F)

#Deleting previous symlinks is best practice, so that if the input changes,
#the old files are not accidentally included
file.remove(list.files(file.path(symdir, "annotations"),
                       include.dirs = F, full.names = T, recursive = T))
file.remove(list.files(file.path(symdir, "annotations", "job_annotations"),
                       include.dirs = F, full.names = T, recursive = T))
file.remove(list.files(file.path(symdir, "objects"),
                       include.dirs = F, full.names = T, recursive = T))
file.remove(list.files(file.path(symdir, "summary"),
                       include.dirs = F, full.names = T, recursive = T))
```

Creating a symlink will fail if it exists already (which we want). Handle the one t-number that has multiple output dirs in MPIF26.

```{r, eval=F}
head(filedict)
stopifnot(all(filedict$t_number[1:3]=="T09-22827"))
stopifnot(all(filedict$panel[1:2]=="MPIF26"))
filedict$t_number[2] <- "T09-22827-B"
```

Also add this entry to the metadata it can be found later.

```{r, eval=F}
combi_meta <- combi_meta %>%
  filter(t_number == "T09-22827" & staining == "MPIF26") %>%
  mutate(t_number = paste0(t_number, "-B")) %>%
  bind_rows(., combi_meta) %>%
  arrange(t_number)
```


### Object results

Add symbolic links to file dictionary.

```{r, eval=F}
filedict$sym_object <- file.path(
  symdir, "objects",
  paste(
    #Deal with T20-62169_I1 and _II1
    str_replace(filedict$t_number, "_", "-"),
        filedict$panel,
        str_remove_all(tolower(filedict$batch)," "), "object_results.csv",
        sep = "_"
    )
)
```

Create the symbolic links.

```{r, eval=F}
#Will harmlessly give a "file exists" warning and return FALSE if already done
suppressWarnings(file.symlink(
  from = filedict$object_path,
  to = filedict$sym_object
))
```

### Summary results

Add symlinks to file dict.

```{r, eval=F}
filedict$sym_summary <- file.path(
  symdir, "summary",
  paste(
    #Deal with T20-62169_I1 and _II1
    str_replace(filedict$t_number, "_", "-"),
        filedict$panel,
        str_remove_all(tolower(filedict$batch)," "), "summary_results.csv",
        sep = "_"
    )
)
```

Create the symbolic links.

```{r, eval=F}
suppressWarnings(file.symlink(
  from = filedict$summary_path,
  to = filedict$sym_summary
))
```

### Annotations

The annotation files that contain `job` in the file name appear to contain less info. Put these in their own subfolder. The files without that string go in the parent directory.

```{r, eval=F}
filedict$sym_annotations <- file.path(
  symdir, "annotations",
  paste(
    #Deal with T20-62169_I1 and _II1
    str_replace(filedict$t_number, "_", "-"),
        filedict$panel,
        str_remove_all(tolower(filedict$batch)," "), "annotations.xml",
        sep = "_"
    )
)
```

Create the symbolic links.

```{r, eval=F}
suppressWarnings(file.symlink(
  from = filedict$anno_path,
  to = filedict$sym_annotations
))
```

Now do the job annotations.

```{r, eval=F}
filedict$sym_job_annotations <- file.path(
  symdir, "annotations", "job_annotations",
  paste(
    #Deal with T20-62169_I1 and _II1
    str_replace(filedict$t_number, "_", "-"),
        filedict$panel,
        str_remove_all(tolower(filedict$batch)," "), "job_annotations.xml",
        sep = "_"
    )
)
```

Create the symbolic links, for those samples that have them.

```{r, eval=F}
suppressWarnings(file.symlink(
  from = filter(filedict, !is.na(anno_job_path))$anno_job_path,
  to = filter(filedict, !is.na(anno_job_path))$sym_job_annotations
))
```

## Write output

Contains original file location and symlink path for all of the result types.

```{r, eval=F}
#Ensure batch matches the the file
filedict <- filedict %>%
  mutate(batch = str_remove_all(tolower(batch), " "))
write_csv(filedict, here("data/metadata/spatial/00_file_location_dictionary.csv"))
```

And track the missing samples.

```{r, eval=F}
write_csv(missing_samples, here("data/metadata/spatial/00_missing_panel_samples.csv"))
```

Report annotation file irregularities.

```{r, eval=F}
write_csv(annos_by_batch, here("data/metadata/spatial/00_annos_by_batch.csv"))
```

Report duplicates and multiples.

```{r, eval=F}
meta %>%
  filter(extern_number %in% dups) %>%
  arrange(extern_number) %>%
  select(extern_number, t_number) %>%
  distinct() %>%
  mutate(irregularity = "patient ref maps to multiple t numbers") %>%
  bind_rows(., mutate(
    select(
      filter(meta, t_number == "T09-22827"),
      extern_number, t_number),
    irregularity = "Two distinct results directories found in MPIF26"
  )) %>%
  mutate(irregularity=ifelse(str_detect(t_number, "\\|"),
                             "Anomalous t number",
                             irregularity)) %>%
  write_csv(here("data/metadata/spatial/00_possible_duplicates.csv"))

```

Metadata that includes clinical outcome

```{r, eval=F}
write_csv(combi_meta, here("data/metadata/spatial/00_vectra_metadata.csv"))
```

Samples for which no clinical outcomes could be found

```{r, eval=F}
combi_meta %>%
  filter(is.na(study_group)) %>%
  select(extern_number, t_number) %>% distinct() %>%
  write_csv(., here("data/metadata/spatial/00_no_clinical_outcome.csv"))
```


```{r, eval=F}
sessionInfo()
```
