---
title: "12_survival"
author: "Kat Moore"
date: "11/7/2019"
output: 
  html_notebook:
    toc: yes
    toc_float: yes
    toc_depth: 4
    highlight: tango
---

```{r}
rm(list = ls())
```

```{r, include=F}
#devtools::install_github('kevinblighe/RegParallel')
#source("https://bioconductor.org/biocLite.R")
#biocLite("GEOquery")
#library(GEOquery) #Example only
#library(Biobase) #Example only
#library(RegParallel) #Example only
library(DESeq2)
library(survival)
library(survminer)
library(pheatmap)
library(ComplexHeatmap)
library(RColorBrewer)
library(glmnet)
library(openxlsx)
library(ROCR)
library(caret)
library(tidyverse)
library(here)
library(ggpubr)
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Pre-process and load data

```{r}
source(here("src", "deseq_report_functions.R"))
```


```{r}
dds = readRDS(here("data/Rds/08_dds_inv_vs_rest_standard.Rds"))
gx_annot <- read_tsv(here("data/metadata/01_tx_annot.tsv"))
gx_annot = gx_annot %>% select(ensembl_gene_id = gene_id, gene_name, gene_type, description = gene_description) %>% distinct()
```


Variance stabilized transformed dds, for visualizations. Converted to gene names and deduplicated.

```{r}
vsd = readRDS(here("data","Rds","09_vsd_standard_vsrest.Rds"))

vsd = rownames_to_column(as.data.frame(assay(vsd)), "ensembl_gene_id")
vsd = right_join(select(gx_annot, gene_name, ensembl_gene_id), vsd, by = "ensembl_gene_id") %>%
    select(-ensembl_gene_id)
vsd = summarize_expression_duplicate_ids(vsd, id_column = "gene_name", verbose = T)
```


## Heatmap colors

Created in notebook 6

```{r}
all_colors = readRDS(here("data","Rds", "06_heatmap_colors.Rds"))
study_colors = all_colors$study_colors
pam_colors = all_colors$pam_colors
gene_colors = all_colors$gene_colors
```

Create data matrix with covariates from the sample data in the first few columns, then genes. Samples are rows.

## Prepare metadata

Covariates: grade, stage, molecular subtype, age at diagnosis and year of diagnosis (Also possibly therapy type)

```{r}
sd = as.data.frame(colData(dds)) %>%
  select(sample_name, death,
         years_overall_survival,
         months_of_followup,
         study_group, PAM50,
         grade, stage,
         inv_vs_rest, prbc_vs_rest,
         lac_vs_rest, nonprbc_vs_rest,
         year_of_diagnosis, age_at_diagnosis,
         overall_survival, months_overall_survival,
         distant_recurrence, months_to_drs,
         local_recurrence_free_survival, months_to_lrs)

#Unnecessary
#sd = sd %>% mutate(
#  grade = as.factor(grade),
#  stage = as.factor(stage),
#  overall_survival = as.factor(overall_survival),
#  distant_recurrence = as.factor(distant_recurrence),
#  local_recurrence_free_survival = as.factor(local_recurrence_free_survival))

head(sd)
```
Exclude samples for which there has been less than 20 months of follow up, unless the reason for the lack of follow up is that the patient passed away due to disease (and not an accident or suicide).

follow_up > 20 | death == 1


```{r, collapse=T}
print(paste("Started with", nrow(sd), "samples"))

print("Samples lost due to lack of survival information:")
nrow(sd %>% filter(is.na(death)))
excluded = sd %>% filter(is.na(death)) %>%
  mutate(reason = "no_survival_data")

print("Samples excluded due to patient death unrelated to disease")
print(nrow(sd %>% filter(! death %in% c(NA, "due to disease", "no"))))
excluded = bind_rows(excluded,
                     mutate(filter(sd, !death %in% c(NA, "due to disease", "no")),
                            reason = "unrelated_death")
                     )
print("Samples due to insufficient follow up")
nrow(sd %>% filter(months_of_followup < 20 & death != "due to disease"))

excluded = bind_rows(excluded,
                     mutate(filter(sd, months_of_followup < 20 & !death == "due to disease"),
                            reason = "insufficient_followup"))

print("Samples with 999 (unknown) years of overall survival")
nrow(sd %>% filter(years_overall_survival == 999))

excluded = bind_rows(excluded,
                     mutate(filter(sd, years_overall_survival == 999),
                            reason = "unknown_survival_years"))

metadata = sd %>% filter(!is.na(death)) %>%
  filter(death != "other cause") %>%
  filter(years_overall_survival != 999) %>%
  filter(months_of_followup >= 20 | death == "due to disease")

print(paste(nrow(metadata), "samples remaining post filtering"))

stopifnot(nrow(filter(metadata,rowSums(is.na(metadata)) > 0)) == 0)
```

## Prepare gene data

The author of the RegParallel packages [argues](https://www.biostars.org/p/344233/#360782) for using VSD, Rlog, or log(cpm) transformations prior to fitting the Cox model.

Intuitively it seems that VSD may overestimate the important of some lowly expressed genes. Try with the log cpm approach first.

```{r}
#fpm (fragments per million) is equivalent to cpm from edgeR
mat = t(log2(fpm(dds, robust=T) + 0.5))

#Exclude those samples which were also excluded from the metadata prep
mat = mat[rownames(mat) %in% metadata$sample_name,]
stopifnot(identical(rownames(mat), metadata$sample_name))
```

Combine into single dataframe for Cox

```{r}
coxdata = cbind(metadata, mat)

head(coxdata)
```

# Basic survival curves

## PPBC

Lactation shows the worst prognosis, followed by involution.

```{r, fig.width = 8}
km_ppbc = survfit(Surv(time=months_overall_survival, event=overall_survival) ~ study_group, data = coxdata) %>% 
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = "OS: All samples with adequate data (n = 177)",
    #linetype = "strata",
    pval = T,
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_ppbc$plot #Avoids printing a blank plot
```

```{r}
table(coxdata$death, coxdata$study_group)
```


```{r, echo=F, include=F}
resDir = here("results", "survival")
dir.create(resDir, showWarnings = F)

pdf(file.path(resDir, "12_km_ppbc.pdf"), width = 8, height = 6)
print(km_ppbc$plot, newpage=F)
dev.off()
```

Survdiff implements the log-rank test, which compares one or more curves vs the null hypothesis that there is no difference in survival between the curves. The log-rank statistic is chi-square distributed.

A comparison between all groups is near but not quite significant.

```{r}
survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ study_group, data = coxdata)
```

Pairwise log-rank tests show that none of the individual pairings are significant, although ppbc_lac vs non-prbc and prbc comes close.

```{r}
pairwise_survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ study_group, data = coxdata)
```

## PAM50

PAM50 shows no significant variance by molecular subtype.

```{r}
km_pam50 = 
survfit(Surv(time=months_overall_survival, event=overall_survival) ~ PAM50, data = coxdata) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = "OS: All samples with adequate data (n = 177)",
    pval = T,
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_pam50$plot
```

```{r, echo=F, include=F}
pdf(file.path(resDir, "12_km_pam50.pdf"), width = 8, height=6)
print(km_pam50$plot)
dev.off()
```

```{r}
table(coxdata$death, coxdata$PAM50)
```



Log-rank test for PAM50. Basal generally has a worse than expected outcome, consistent with the literature. The others are almost exactly matched with expected.

```{r}
survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ PAM50, data = coxdata)
```

Pairwise log-rank tests demonstrate that no pairing is remotely significant.

```{r}
pairwise_survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ PAM50, data = coxdata)
```

# Basic DRS curves

## PPBC

Just like OS, lactation shows the worst prognosis, followed by involution. But non-prbc is closer behind.

```{r, fig.width = 8}
drs_ppbc = survfit(Surv(time=months_to_drs, event=distant_recurrence) ~ study_group, data = coxdata) %>% 
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "DRS probability",
    title = "DRS: All samples with adequate data (n = 177)",
    #linetype = "strata",
    pval = T,
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

drs_ppbc$plot #Avoids printing a blank plot
```

```{r}
table(coxdata$distant_recurrence, coxdata$study_group)
```


```{r, echo=F, include=F}
resDir = here("results", "survival")
dir.create(resDir, showWarnings = F)

pdf(file.path(resDir, "12_drs_ppbc.pdf"), width = 8, height = 6)
print(drs_ppbc$plot, newpage=F)
dev.off()
```

A comparison between all groups is not significant.

```{r}
survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ study_group, data = coxdata)
```

Pairwise log-rank tests show that none of the individual pairings are at or near significance.

```{r}
pairwise_survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ study_group, data = coxdata)
```

## PAM50

PAM50 shows no significant variance by molecular subtype.

```{r}
drs_pam50 = 
survfit(Surv(time=months_to_drs, event=distant_recurrence) ~ PAM50, data = coxdata) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "DRS probability",
    title = "DRS: All samples with adequate data (n = 177)",
    pval = T,
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

drs_pam50$plot
```

```{r, echo=F, include=F}
pdf(file.path(resDir, "12_drs_pam50.pdf"), width = 8, height=6)
print(drs_pam50$plot)
dev.off()
```

```{r}
table(coxdata$distant_recurrence, coxdata$PAM50)
```

Log-rank test for PAM50 is similar to OS. Basal generally has a worse than expected outcome,the others match approximately with expected.

```{r}
survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ PAM50, data = coxdata)
```

Pairwise log-rank tests demonstrate that no pairing is remotely significant.

```{r}
pairwise_survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ PAM50, data = coxdata)
```

# Univariate Cox

## Study gorup

Non-prbc (nulliparous) is the reference group. A positive coefficient indicates an increased risk vs the reference, whereas a negative coefficient indicates a comparatively better prognosis vs the reference. The exponentiated coefficient exp(coef) is equivalent to the hazard ratio.

    HR = 1: No effect
    HR < 1: Reduction in the hazard
    HR > 1: Increase in Hazard

Lac and inv both have higher risk than non-prbc, but only lac is significant. Prbc has a lower risk than non-prbc.

```{r}
cox.ppbc <- coxph(Surv(time=months_overall_survival, event=overall_survival) ~ study_group, data = coxdata)
summary(cox.ppbc)
```

## PAM50

Congruent with the Kaplan-Meijer, no PAM50 group is significantly better or worse than the rest.

```{r}
cox.pam <- coxph(Surv(time=months_overall_survival, event=overall_survival) ~ PAM50, data = coxdata)
summary(cox.pam)
```

## Sequential univariate analysis of other covariate

Of the remaining covariates, only stage is significant.

```{r}
covariates <- c("age_at_diagnosis", "year_of_diagnosis","stage","grade")
res.simple.univ <- sapply(
  covariates,function(x) as.formula(paste('Surv(time=months_overall_survival, event=overall_survival)~', x))) %>%
  lapply(., function(x){coxph(x, data = coxdata)}) %>%
  lapply(.,
                       function(x){ 
                          x <- summary(x)
                          p.value<-signif(x$wald["pvalue"], digits=2)
                          wald.test<-signif(x$wald["test"], digits=2)
                          beta<-signif(x$coef[1], digits=2);#coeficient beta
                          HR <-signif(x$coef[2], digits=2);#exp(beta)
                          HR.confint.lower <- signif(x$conf.int[,"lower .95"], 2)
                          HR.confint.upper <- signif(x$conf.int[,"upper .95"],2)
                          HR <- paste0(HR, " (", 
                                       HR.confint.lower, "-", HR.confint.upper, ")")
                          res<-c(beta, HR, wald.test, p.value)
                          names(res)<-c("beta", "HR (95% CI for HR)", "wald.test", 
                                        "p.value")
                          return(res)
                          #return(exp(cbind(coef(x),confint(x))))
                         })
res.simple.univ <- t(as.data.frame(res.simple.univ, check.names = FALSE))
as.data.frame(res.simple.univ)
```

Distribution of stage over the study groups. Note that lactation has no patients in stage 1, which may contribute to the poorer prognosis in that group.

```{r}
table(coxdata$stage, coxdata$study_group)
```

## Heatmap cancer stage

```{r}
#par(mfrow=c(1,2))
pheatmap(as.matrix(table(coxdata$stage, coxdata$study_group)),
         scale="none", 
         display_numbers = T,
         number_format = "%.0f",
         cluster_rows = F, cluster_cols = F,
         main = "Study group by stage")

pheatmap(as.matrix(table(coxdata$stage, coxdata$study_group)),
         scale="column", 
         display_numbers = T,
         number_format = "%.2f",
         cluster_rows = F, cluster_cols = F,
         main = "Study group by stage, scaled by group")
```


```{r}
chisq.test(table(coxdata$stage, coxdata$study_group))
```



# Multivariate Cox

## All covariates

Including all clinical covariates, 11 total levels.

The LRT, Wald and logrank tests are all below 0.05. These tests evaluate the null hypothesis that the beta for every covariate is 0. The result indicates that the model overall is significant.

For increased risk, stage is significant at p < 0.001 and HR 2.6, while both involution and lactation are near significance with p < 0.1 and HR 2.4 and 3.2, respectively.

Her2 and LumB show significantly decreased risk at p < 0.05 and HRs 0.2 and 0.41, resepctively.

```{r}
clin.cov.cox <- coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis + year_of_diagnosis + grade + stage + PAM50 + study_group,
  data = coxdata)
summary(clin.cov.cox)
```

## Significant covariates

If limited to only those covariates which were significant in the univariate analysis, the results are similar. Most of the PAM50 comparisons are positively prognostic compared to basal at p < 0.1. Involution remains significant at p < 0.1, but lactation drifts out of the significant range.

```{r}
select.clin.cov.cox <- coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~  stage + PAM50 + study_group,
  data = coxdata)
summary(select.clin.cov.cox)
```

## Multivariate plot for study group

Estimate the impact of study group in the multivariate model. Requires constructing a new data frame with one row for each value of the covariate of interest; the other covariates are fixed to their average values (if they are continuous variables) or to their lowest level (if they are discrete variables).

There are comparatively few normal subtypes, so we will ignore it for this purpose.

```{r}
table(coxdata$PAM50, coxdata$study_group)
```

```{r}
study_df = coxdata %>%
  group_by(study_group) %>%
  summarize(age_at_diagnosis = mean(age_at_diagnosis),
            year_of_diagnosis = mean(year_of_diagnosis),
            grade = mean(grade),
            stage = mean(stage))

#Order: non_prbc, inv, lac, prbc
study_df$PAM50 = c("Her2", "Basal", "LumA", "LumB")
```

This data frame is passed to survfit() via the newdata argument:

```{r, fig.width=9, fig.height=6}
#survfit(clin.cov.cox, newdata = study_df)
plot.clin.cov.cox <- ggsurvplot(survfit(clin.cov.cox, newdata = study_df), conf.int = TRUE,
           legend.labs=c("non_prbc", "ppbc_inv", "ppbc_lac", "prbc"),
           ggtheme = theme_minimal(), data=coxdata,
           title = "Survival ~ age_at_diagnosis + year_of_diagnosis + grade + stage + PAM50 + study_group")
plot.clin.cov.cox$plot
```

```{r, echo=F, include=F}
pdf(file.path(resDir, "12_curve_multivariate_ppbc.pdf"),width = 9, height = 6)
print(plot.clin.cov.cox$plot)
dev.off()
```



# Independent genewise Cox regression

```{r}
extract_genewise_cox_results <- function(cox_models, type){
  
  #Cox models generated as follows:
  #gene_formulas <- sapply(gene_vector,function(x) as.formula(paste('Surv(time, event)~', x)))
  #cox_models <- lapply(gene_formulas, function(x){coxph(x, data = coxdata)})
  
  stopifnot(type %in% c("univariate", "multivariate"))
  
  if(type == "univariate"){
    univ_gene_results <- lapply(cox_models,
                                function(x){ 
                                  x <- summary(x)
                                  p.value<-signif(x$wald["pvalue"], digits=2)
                                  #wald.test<-signif(x$wald["test"], digits=2) #Unnecessary
                                  beta<-signif(x$coef[1], digits=2);#coeficient beta
                                  HR <-signif(x$coef[2], digits=2);#exp(beta)
                                  HR.confint.lower <- signif(x$conf.int[,"lower .95"], 2)
                                  HR.confint.upper <- signif(x$conf.int[,"upper .95"],2)
                                  HR <- paste0(HR, " (", 
                                               HR.confint.lower, "-", HR.confint.upper, ")")
                                  res<-c(beta, HR,
                                         #wald.test,
                                         p.value)
                                  names(res)<-c("beta", "HR (95% CI for HR)", #"wald.test", 
                                                "p.value")
                                  return(res)
                                  #return(exp(cbind(coef(x),confint(x))))
                                })
    
    res_df <- t(as.data.frame(univ_gene_results, check.names = FALSE))
  }
  
  if(type == "multivariate"){
    multivar_gene_results <- lapply(cox_models,
                                    function(x){
                                      x <- summary(x)
                                      #Drop the other formula elements
                                      coefs <- as.data.frame(x$coefficients)
                                      coefs <- rownames_to_column(coefs, "ensembl_gene_id")
                                      gene = tail(coefs$ensembl_gene_id,1)
                                      coefs <- coefs[coefs$ensembl_gene_id==gene, , drop=F]
                                      colnames(coefs) <- c("ensembl_gene_id", "beta", "HR", "se(beta)", "z", "p.value")
                          
                                      #Extract p val and stats for gene of interest
                                      p.value<-signif(coefs$p.value, digits = 2)
                                      beta<-signif(coefs$beta, digits=2);#coeficient beta
                                      HR <-signif(coefs$HR, digits=2);#exp(beta)
                          
                                      #Do the same for conf intervals
                                      conf.int = rownames_to_column(as.data.frame(x$conf.int), "ensembl_gene_id")
                                      conf.int = conf.int[conf.int$ensembl_gene_id==gene, , drop=F]
                                      HR.confint.lower <- signif(conf.int[,"lower .95"], 2)
                                      HR.confint.upper <- signif(conf.int[,"upper .95"],2)
                                      HR <- paste0(HR, " (", 
                                                   HR.confint.lower, "-", HR.confint.upper, ")")
                                      res<-c(beta, HR, p.value)
                                      names(res)<-c("beta", "HR (95% CI for HR)","p.value")
                                      return(res)
                                      })
    
    res_df <- t(as.data.frame(multivar_gene_results, check.names = FALSE))
  }
  
  df = as.data.frame(res_df) %>%
      rownames_to_column("ensembl_gene_id") %>%
      left_join(., gx_annot,by="ensembl_gene_id") %>%
      mutate(p.value = as.numeric(as.character(p.value)),
             beta = as.numeric(as.character(beta))) %>%
      select(gene_name, p.value, everything()) %>%
      arrange(p.value)
  
  return(df)
}

```

```{r}
genewise_cox <- function(gene_list, time, event, data = coxdata, type, show_runtime=T){
  stopifnot(type %in% c("univariate", "multivariate"))
  stopifnot(time %in% colnames(data))
  stopifnot(event %in% colnames(data))
  
  start <- Sys.time()
  
  formula = paste0('Surv(time=',time,', event=',event,')~')
  
  if(type == "multivariate"){
    formula = paste0(formula,'age_at_diagnosis+year_of_diagnosis+stage+grade+PAM50+')
    formula = 'Surv(time=months_overall_survival, event=overall_survival)~age_at_diagnosis+year_of_diagnosis+stage+grade+PAM50+'
  }
  
  gene_formulas <- sapply(gene_list, function(x) as.formula(paste(formula, x)))
  gene_models <- lapply(gene_formulas, function(x){coxph(x, data = data)})
  res <- extract_genewise_cox_results(gene_models, type=type)
  end <- Sys.time()
  
  if(show_runtime){print(end-start)}
  return(res)
}

```

# Overall survival: involution vs rest

Significant genes in the Wald test involution vs all other groups, as described in notebook 8.

```{r}
#excel_sheets(here("results","diffex", "08_one_vs_rest_sig_genes.xlsx"))
sig_inv_rest = readxl::read_excel(here("results","diffex", "08_one_vs_rest_sig_genes.xlsx"),sheet="sig_rep_inv_rest" )
#head(sig_inv_rest)

stopifnot(sum(duplicated(sig_inv_rest$ensembl_gene_id))==0)
```

## Univariate Cox by gene


```{r}
res_inv_univ_surv <- genewise_cox(sig_inv_rest$ensembl_gene_id, coxdata,
                                  time="months_overall_survival",
                                  event="overall_survival",
                                  type="univariate")
```

With only 51 genes significant for involution vs rest, we can page through all of them.

```{r}
res_inv_univ_surv
```

Genes significantly associated with a negative outcome:

(None)

```{r}
res_inv_univ_surv %>% filter(p.value < 0.1 & beta > 0)
```

Genes significantly associated with a positive outcome:

```{r}
res_inv_univ_surv %>% filter(p.value < 0.1 & beta < 0)
```

## Multivariate Cox by gene

Using all clinical covariates (except study group)

```{r}
res_inv_multivar_surv = genewise_cox(sig_inv_rest$ensembl_gene_id, coxdata,
                                  time="months_overall_survival",
                                  event="overall_survival",
                                  type="multivariate")
```

```{r}
res_inv_multivar_surv %>% arrange(p.value)
```


Genes significantly associated with a negative outcome:

(None)

```{r}
res_inv_multivar_surv %>% filter(p.value < 0.1 & beta > 0)
```

Genes significantly associated with a positive outcome:

```{r}
res_inv_multivar_surv %>% filter(p.value < 0.1 & beta < 0)
```

Overlap between the univariate and multivariate models:

```{r}
intersect(pull(filter(res_inv_univ_surv, p.value < 0.1),gene_name),
          pull(filter(res_inv_multivar_surv, p.value < 0.1),gene_name))
```



# Metastasis/DR: involution vs rest

distant_recurrence = metastasis, including those which were metastatic at diagnosis. These are those that were metastatic at diagnosis.

Some samples have months_to_drs = 0

```{r}
colData(dds) %>% as.data.frame() %>%
  filter(months_to_drs == 0) %>% select(sample_name, months_to_drs, metastasis_at_diagnosis)

met_at_diag = colData(dds) %>% as.data.frame() %>%
  filter(months_to_drs == 0) %>% select(sample_name, months_to_drs, metastasis_at_diagnosis) %>%
  pull(sample_name)
```


## Univariate Cox by gene

```{r}
res_inv_univ_dr = genewise_cox(sig_inv_rest$ensembl_gene_id, coxdata,
                                  time="months_to_drs",
                                  event="distant_recurrence",
                                  type="univariate")
```

Page through results

```{r}
res_inv_univ_dr
```

Genes significantly associated with a negative outcome:

(Still none)

```{r}
res_inv_univ_dr %>% filter(p.value < 0.1 & beta > 0)
```

Genes significantly associated with a positive outcome:

```{r}
res_inv_univ_dr %>% filter(p.value < 0.1 & beta < 0)
```

## Multivariate Cox by gene

Using all clinical covariates (except study group) for metastasis/distant recurrence.

```{r}
res_inv_multivar_dr = genewise_cox(sig_inv_rest$ensembl_gene_id, coxdata,
                                  time="months_to_drs",
                                  event="distant_recurrence",
                                  type="multivariate")
```


Genes significantly associated with a negative outcome:

(None)

```{r}
res_inv_multivar_dr %>% filter(p.value < 0.1 & beta > 0)
```

Genes significantly associated with a positive outcome:

```{r}
res_inv_multivar_dr %>% filter(p.value < 0.1 & beta < 0)
```

Overlap between the univariate and multivariate models:

```{r}
intersect(pull(filter(res_inv_univ_dr, p.value < 0.1),gene_name),
          pull(filter(res_inv_multivar_dr, p.value < 0.1),gene_name))
```


## Write results: inv vs rest

```{r, warning=F}
meta_sig_inv <- tibble(
  Name = c("input_diffex",
           "univ_cox_surv",
           "univ_cox_dr",
           "multi_cox_surv",
           "multi_cox_dr",
           "metadata"),
  Type = c("Significant genes from comparison involution vs rest",
            rep("Univariate",2),
            rep("Multivariate",2),
           "sample metadata"),
  Formula = c("~batch+PAM50+inv_vs_rest",
              "Surv(time=months_overall_survival,event=overall_survival)~gene",
              "Surv(time=months_to_drs,event=distant_recurrence)~gene",
              "Surv(time=months_overall_survival,event=overall_survival)~age_at_diagnosis+year_of_diagnosis+stage+grade+PAM50+gene",
              "Surv(time=months_to_drs,event=distant_recurrence)~age_at_diagnosis+year_of_diagnosis+stage+grade+PAM50+gene",
              NA),
  Package = c("DESeq2", rep("survival/survminer",4), NA),
  Test = c("Diffex/Wald", "Cox survival", "Cox metatasis", "Cox survival", "Cox metatasis", NA))

#head(meta_sig_inv)
openxlsx::write.xlsx(list(description = meta_sig_inv,
                          univ_cox_surv = res_inv_univ_surv,
                          univ_cox_dr = res_inv_univ_dr,
                          multi_cox_surv = res_inv_multivar_surv,
                          multi_cox_dr = res_inv_multivar_dr,
                          input_diffex = sig_inv_rest,
                          metadata = as.data.frame(colData(dds))),
                     file = here("results", "survival", "12_cox_inv_vs_rest_genes.xlsx"))
```


# All genes: overall survival

```{r}
resDir = here("data", "Rds")
```


Within coxdata, gene names start at position 21

```{r, include=F}
colnames(coxdata)[20:23]
```

## Multivariate survival

Run in script 12, results loaded here. Approx ~30 min runtime.

```{r, eval=F}
start <- Sys.time()
multivar_gene_formulas <- sapply(
  colnames(coxdata)[21:ncol(coxdata)],
  function(x) as.formula(
    paste(
      'Surv(time=months_overall_survival, event=overall_survival)~age_at_diagnosis+year_of_diagnosis+stage+grade+PAM50+',
      x)))
                        
multivar_gene_models <- lapply(multivar_gene_formulas, function(x){coxph(x, data = coxdata)})
end <- Sys.time()
end-start
saveRDS(multivar_gene_models, file=file.path(resDir, "12_allgenes_multivar_surv.Rds"))
```

>Time difference of 30.01901 mins

```{r}
multivar_gene_surv <- readRDS(file=here("data","Rds", "12_allgenes_multivar_surv.Rds"))
```

With ~30K genes, we'll need to apply multiple testing correction.

```{r}
start <- Sys.time()
res_allgenes_multivar_surv <- extract_genewise_cox_results(cox_models = multivar_gene_surv,
                                                      type = "multivariate") %>%
  mutate(fdr = p.adjust(p.value, method = "fdr")) %>%
  select(gene_name, fdr, beta, `HR (95% CI for HR)`, everything())

end <- Sys.time()

print(end-start)
```

Top 30 most significant results.

```{r}
head(res_allgenes_multivar_surv, 30)
```


### Correlation poor prognosis

Higher gene expression = worse prognosis

Using a generous fdr threshold of 0.2:

```{r}
print(paste("Number of genes negatively associated with survival, fdr < 0.2:",
      nrow(res_allgenes_multivar_surv %>% filter(beta > 0 & fdr < 0.2))))

res_allgenes_multivar_surv %>% filter(beta > 0 & fdr < 0.2) %>%
  select(description, gene_name, everything())
```

Without multiple testing correction (just for thoroughness):

```{r}
print(paste("Number of genes negatively associated with survival, pval < 0.01:",
      nrow(res_allgenes_multivar_surv %>% filter(beta > 0 & p.value < 0.01))))
res_allgenes_multivar_surv %>% filter(beta > 0 & p.value < 0.01) %>%
  select(description, gene_name, everything()) %>% head(20)
```

### Correlation good prognosis

Higher gene expression = better prognosis

Generous fdr cutoff of 0.2:

```{r}
print(paste("Number of genes positively associated with survival, fdr < 0.2:",
      nrow(res_allgenes_multivar_surv %>% filter(beta < 0 & fdr < 0.2))))
res_allgenes_multivar_surv %>% filter(beta < 0 & fdr < 0.2) %>%
  select(description, gene_name, everything())
```

For thorougness, based on p val alone:

```{r}
print(paste("Number of genes positively associated with survival, pval < 0.01:",
      nrow(res_allgenes_multivar_surv %>% filter(beta < 0 & p.value < 0.01))))
res_allgenes_multivar_surv %>% filter(beta > 0 & p.value < 0.01) %>%
  select(description, gene_name, everything()) %>% head(20)
```

## Univariate survival

```{r, eval=F}
start <- Sys.time()
univ_gene_formulas <- sapply(
  colnames(coxdata)[21:ncol(coxdata)],
  function(x) as.formula(
    paste(
      'Surv(time=months_overall_survival, event=overall_survival)~',
      x)))

univ_gene_models <- lapply(univ_gene_formulas, function(x){coxph(x, data = coxdata)})
end <- Sys.time()
print(end-start)
```

>Warning messages:
1: In fitter(X, Y, strats, offset, init, control, weights = weights,  :
  Loglik converged before variable  1 ; coefficient may be infinite. 
2: In fitter(X, Y, strats, offset, init, control, weights = weights,  :
  Loglik converged before variable  1 ; coefficient may be infinite. 
3: In fitter(X, Y, strats, offset, init, control, weights = weights,  :
  Loglik converged before variable  1 ; coefficient may be infinite. 
Time difference of 29.6996 mins

```{r}
univ_gene_surv <- readRDS(here("data", "Rds", "12_allgenes_univ_surv.Rds"))
```

With ~30K genes, we'll need to apply multiple testing correction.

```{r}
start <- Sys.time()
res_allgenes_univ_surv <- extract_genewise_cox_results(cox_models = univ_gene_surv,
                                                      type = "univariate") %>%
  mutate(fdr = p.adjust(p.value, method = "fdr")) %>%
  select(gene_name, fdr, beta, `HR (95% CI for HR)`, everything())

end <- Sys.time()

print(end-start)
```

Top 30 most significant results.

```{r}
head(res_allgenes_univ_surv, 30)
```


### Poor prognosis

Higher gene expression = worse prognosis

Using a generous fdr threshold of 0.2:

```{r}
print(paste("Number of genes negatively associated with survival, fdr < 0.2:",
      nrow(res_allgenes_univ_surv %>% filter(beta > 0 & fdr < 0.2))))

res_allgenes_univ_surv %>% filter(beta > 0 & fdr < 0.2) %>%
  select(description, gene_name, everything())
```

Without multiple testing correction (just for thoroughness):

```{r}
print(paste("Number of genes negatively associated with survival, pval < 0.01:",
      nrow(res_allgenes_univ_surv %>% filter(beta > 0 & p.value < 0.01))))
res_allgenes_univ_surv %>% filter(beta > 0 & p.value < 0.01) %>%
  select(description, gene_name, everything()) %>% head(20)
```

### Good prognosis

Higher gene expression = better prognosis

At FDR < 0.2, there is nothing. For exploration purposes, an even more generous fdr of 0.3

```{r}
print(paste("Number of genes positively associated with survival, fdr < 0.3:",
      nrow(res_allgenes_univ_surv %>% filter(beta < 0 & fdr < 0.3))))
res_allgenes_univ_surv %>% filter(beta < 0 & fdr < 0.3) %>%
  select(description, gene_name, everything())
```

For thoroughness, based on p val alone:

```{r}
print(paste("Number of genes positively associated with survival, pval < 0.01:",
      nrow(res_allgenes_univ_surv %>% filter(beta < 0 & p.value < 0.01))))
res_allgenes_univ_surv %>% filter(beta > 0 & p.value < 0.01) %>%
  select(description, gene_name, everything()) %>% head(20)
```

## Comparing multivariate and univariate

```{r}
tibble(fdr_uni = res_allgenes_univ_surv$fdr, 
       fdr_multi = res_allgenes_multivar_surv$fdr) %>%
  ggplot(aes(x=fdr_uni, y = fdr_multi)) + geom_point() +
  geom_smooth() +
  ggtitle("Comparison genewise fdr uni/multivariate Cox models: OS")
```


# All genes: Metastasis/DR

distant_recurrence = metastasis, including those which were metastatic at diagnosis

```{r}
print("Distant_recurrence x metastasis at diagnosis:")
print(table(colData(dds)$distant_recurrence, colData(dds)$metastasis_at_diagnosis))
```

## Multivariate DR

Run in script 12, with results loaded ex post facto.

```{r, eval=F}
if(file.exists(file.path(resDir, "12_allgenes_multivar_dr.Rds")) == F | overwrite == T){
  print("Starting multivariate analysis for distant recurrence")
  start <- Sys.time()
  multivar_gene_formulas <- sapply(
    colnames(coxdata)[21:ncol(coxdata)],
    function(x) as.formula(
      paste(
        'Surv(time=months_to_drs, event=distant_recurrence)~age_at_diagnosis+year_of_diagnosis+stage+grade+PAM50+',
        x)))

  multivar_gene_models <- lapply(multivar_gene_formulas, function(x){coxph(x, data = coxdata)})
  end <- Sys.time()
  print(end-start)

  saveRDS(multivar_gene_models, file=file.path(resDir, "12_allgenes_multivar_dr.Rds"))
}
```

>Time difference of 31.40221 mins
Warning messages:
1: In fitter(X, Y, strats, offset, init, control, weights = weights,  :
  Loglik converged before variable  4 ; coefficient may be infinite. 
2: In fitter(X, Y, strats, offset, init, control, weights = weights,  :
  Loglik converged before variable  4 ; coefficient may be infinite. 

```{r}
multivar_gene_dr = readRDS(file.path(resDir, "12_allgenes_multivar_dr.Rds"))
```

With ~30K genes, we'll need to apply multiple testing correction.

```{r}
start <- Sys.time()
res_allgenes_multivar_dr <- extract_genewise_cox_results(cox_models = multivar_gene_dr,
                                                      type = "multivariate") %>%
  mutate(fdr = p.adjust(p.value, method = "fdr")) %>%
  select(gene_name, fdr, beta, `HR (95% CI for HR)`, everything())

end <- Sys.time()

print(end-start)
```

Top 30 most significant results.

```{r}
head(res_allgenes_multivar_dr, 30)
```


### Poor prognosis

Higher gene expression = worse prognosis

Using a generous fdr threshold of 0.2.

Now we find a few things!

```{r}
print(paste("Number of genes negatively associated with metastasis, fdr < 0.2:",
      nrow(res_allgenes_multivar_dr %>% filter(beta > 0 & fdr < 0.2))))

res_allgenes_multivar_dr %>% filter(beta > 0 & fdr < 0.2) %>%
  select(description, gene_name, everything())
```

Without multiple testing correction (just for thoroughness):

```{r}
print(paste("Number of genes negatively associated with metastasis, pval < 0.01:",
      nrow(res_allgenes_multivar_dr %>% filter(beta > 0 & p.value < 0.01))))
#res_allgenes_multivar_dr %>% filter(beta > 0 & p.value < 0.01) %>%
#  select(description, gene_name, everything()) %>% head(20)
```

### Good prognosis

Higher gene expression = better prognosis

Generous fdr cutoff of 0.2:

Foxp3 and Stat5a are there!

```{r}
print(paste("Number of genes positively associated with metastasis, fdr < 0.2:",
      nrow(res_allgenes_multivar_dr %>% filter(beta < 0 & fdr < 0.2))))
res_allgenes_multivar_dr %>% filter(beta < 0 & fdr < 0.2) %>%
  select(description, gene_name, everything())
```

For thorougness, based on p val alone:

```{r}
print(paste("Number of genes positively associated with metastasis, pval < 0.01:",
      nrow(res_allgenes_multivar_dr %>% filter(beta < 0 & p.value < 0.01))))
#res_allgenes_multivar_dr %>% filter(beta > 0 & p.value < 0.01) %>%
#  select(description, gene_name, everything()) %>% head(20)
```

## Univariate DR

Run in script 12, with results loaded ex post facto.

```{r, eval=F}
if(file.exists(file.path(resDir, "12_allgenes_univ_dr.Rds")) == F | overwrite == T){
  print("Starting univariate analysis for distant recurrence")
  start <- Sys.time()
  univ_gene_formulas <- sapply(
    colnames(coxdata)[21:ncol(coxdata)],
    function(x) as.formula(
      paste(
        'Surv(time=months_to_drs, event=distant_recurrence)~',
        x)))

  univ_gene_models <- lapply(univ_gene_formulas, function(x){coxph(x, data = coxdata)})
  end <- Sys.time()
  print(end-start)

  saveRDS(univ_gene_models, file=file.path(resDir, "12_allgenes_univ_dr.Rds"))
}
```

>Time difference of 30.5964 mins
Warning messages:
1: In fitter(X, Y, strats, offset, init, control, weights = weights,  :
  Loglik converged before variable  1 ; coefficient may be infinite. 
2: In fitter(X, Y, strats, offset, init, control, weights = weights,  :
  Loglik converged before variable  1 ; coefficient may be infinite. 

```{r}
univ_gene_dr = readRDS(file=file.path(resDir, "12_allgenes_univ_dr.Rds"))
```

With ~30K genes, we'll need to apply multiple testing correction.

```{r}
start <- Sys.time()
res_allgenes_univ_dr <- extract_genewise_cox_results(cox_models = univ_gene_dr,
                                                      type = "univariate") %>%
  mutate(fdr = p.adjust(p.value, method = "fdr")) %>%
  select(gene_name, fdr, beta, `HR (95% CI for HR)`, everything())

end <- Sys.time()

print(end-start)
```

Top 30 most significant results.

```{r}
head(res_allgenes_univ_surv, 30)
```


### Poor prognosis

Higher gene expression = worse prognosis

Here there are far, far more genes significant when using an fdr threshold of 0.2 than with the multivariate distant recurrence model.

```{r}
print(paste("Number of genes negatively associated with metastasis, fdr < 0.2:",
      nrow(res_allgenes_univ_dr %>% filter(beta > 0 & fdr < 0.2))))

#res_allgenes_univ_dr %>% filter(beta > 0 & fdr < 0.2) %>%
#  select(description, gene_name, everything())
```

Looking at those genes with an fdr < 0.05:

```{r}
print(paste("Number of genes negatively associated with distant recurrence, fdr < 0.05:",
      nrow(res_allgenes_univ_dr %>% filter(beta > 0 & fdr < 0.05))))

res_allgenes_univ_dr %>% filter(beta > 0 & fdr < 0.05) %>%
  select(description, gene_name, everything())
```


### Good prognosis

Higher gene expression = better prognosis

Also here there are far more fdr significant genes than in the multivariate model.

```{r}
print(paste("Number of genes positively associated with metastasis, fdr < 0.05:",
      nrow(res_allgenes_univ_dr %>% filter(beta < 0 & fdr < 0.05))))
res_allgenes_univ_dr %>% filter(beta < 0 & fdr < 0.05) %>%
  select(description, gene_name, everything())
```


## Comparing multivariate and univariate

```{r}
tibble(fdr_uni = res_allgenes_univ_dr$fdr, 
       fdr_multi = res_allgenes_multivar_dr$fdr) %>%
  ggplot(aes(x=fdr_uni, y = fdr_multi)) + geom_point() +
  geom_smooth() +
  ggtitle("Comparison genewise fdr uni/multivariate Cox models: DRS")
```



## Write results: all genes

Combine overall survival and metastasis Cox models for all genes.

```{r, warning=F}
meta_allgenes <- tibble(
  Name = c("univ_cox_surv",
           "univ_cox_dr",
           "multi_cox_surv",
           "multi_cox_dr",
           "metadata",
           "input_diffex"),
  Type = c(rep("Univariate",2),
            rep("Multivariate",2),
           "sample metadata",
           "log2 cpm normalized gene expression matrix"),
  Formula = c("Surv(time=months_overall_survival,event=overall_survival)~gene",
              "Surv(time=months_to_drs,event=distant_recurrence)~gene",
              "Surv(time=months_overall_survival,event=overall_survival)~age_at_diagnosis+year_of_diagnosis+stage+grade+PAM50+gene",
              "Surv(time=months_to_drs,event=distant_recurrence)~age_at_diagnosis+year_of_diagnosis+stage+grade+PAM50+gene",
              NA, NA),
  Package = c(rep("survival/survminer",4), NA, NA),
  Test = c("Cox survival", "Cox metastasis", "Cox survival", "Cox metastasis", NA, "Log2/Cpm"))


openxlsx::write.xlsx(list(description = meta_allgenes,
                          univ_cox_surv = res_allgenes_univ_surv,
                          univ_cox_dr = res_allgenes_univ_dr,
                          multi_cox_surv = res_allgenes_multivar_surv,
                          multi_cox_dr = res_allgenes_multivar_dr,
                          metadata = as.data.frame(colData(dds)),
                          input_norm_geneEx = rownames_to_column(as.data.frame(t(mat)), "ensembl_gene_id")),
                     file = here("results", "survival", "12_cox_allgenes.xlsx"))
```

# Covariate selection with Cox Elastic Net

A pentalized cox model to determine which groups of covariates are most predictive of survival.

We'll want two versions: One matrix with just the gene expression, and one with gene expression plus clinical covariates.

```{r}
enet.gene <- coxdata[,21:ncol(coxdata)] #Gene names start at position 21
rownames(enet.gene) <- coxdata$sample_name
enet.gene <- as.matrix(enet.gene)


enet.clin <- coxdata[,c(which(colnames(coxdata) %in% covariates), 21:ncol(coxdata))]
rownames(enet.clin) <- coxdata$sample_name
enet.clin <- as.matrix(enet.clin)
```


For family="cox", y should be a two-column matrix with columns named 'time' and 'status'. The latter is a binary variable, with '1' indicating death, and '0' indicating right censored.  

Overall survival

```{r}
os = data.frame(time = coxdata$months_overall_survival, event = coxdata$overall_survival)
rownames(os) = coxdata$sample_name

#os = as.matrix(os)
os = Surv(os$time, os$event)
head(os)
```

Metastasis
When looking at drs, time point 0 (metastatic at diagnosis) is not allowed

```{r}
drs = data.frame(time = coxdata$months_to_drs, event = coxdata$distant_recurrence)
rownames(drs) = coxdata$sample_name
drs = drs[!rownames(drs) %in% met_at_diag,]
#Some samples have months_to_drs = 0

drs = drs[drs$time!=0,]
#drs = as.matrix(drs)
drs = Surv(drs$time, drs$event)
head(drs)

enet.gene.drs = enet.gene[!(rownames(enet.gene) %in% met_at_diag),]
enet.clin.drs = enet.clin[!(rownames(enet.clin) %in% met_at_diag),]
```

```{r}
nested.cox <- function(x,y,nfolds=10,nfolds_inner=10,
                       s="lambda.min",
                       alpha=0.5){
  #Based on nested.cv from the TANDEM package

  n = length(y)
  foldid = ceiling(sample(1:n)/n * nfolds)
  
  fitted_relative_risk = rep(NA, length(y))
  #y_hat = rep(NA, length(y))
  
  features = list()
  fitplots = list()
  results = list()
  
  for (i in 1:nfolds) {
      ind = foldid == i
      x_train = x[!ind, ]
      y_train = y[!ind]
      x_test = x[ind, ]
      n_i = length(y_train)
      foldid_i = ceiling(sample(1:n_i)/n_i * nfolds_inner)
      fit = glmnet::cv.glmnet(x_train, y_train, family = "cox", alpha = alpha,
                              foldid = foldid_i)
      fitplots[[length(fitplots) + 1]] = fit
      features[[length(features) + 1]] = coef(fit, s=s)[,1] %>% enframe() %>% filter(value!=0 & name != "(Intercept)")
      fitted_relative_risk[ind] = as.vector(glmnet::predict.cv.glmnet(fit, 
              newx = x_test, s = s, alpha=alpha, type="response"))
        
      print(i) 
      }

  results$features <- features
  results$fitplots <- fitplots
  
  return(results)
}
```


## Overall survival

Run in script 12, results loaded here.

### OS genes as features

```{r, eval=F}
set.seed(123)
start <- Sys.time()
glm.os <- nested.cox(x = enet.gene, y = os, s = "lambda.min", alpha = 0.5)
end <- Sys.time()
print(end-start)
saveRDS(glm.os, file.path(resDir,"12_glm_os_gene.Rds"))
```

```{r}
glm.os <- readRDS(file.path(resDir,"12_glm_os_gene.Rds"))
```


#### Model plots

Plots of 10 cross-validation runs. Performance is fairly consitent below 100 transcripts, with little performance gained from 1 to ~60 features selected.

```{r, fig.width=8, fig.height=10}
par(mar=c(4,4,2,2))
par(mfrow=c(5,2))
lapply(glm.os$fitplots, plot)
```


```{r, include=F}
pdf(here("results", "survival", "models_os_gene.pdf"))
par(mar=c(4,4,2,2))
par(mfrow=c(5,2))
lapply(glm.os$fitplots, plot)
dev.off()
```


Zoom in on a sample plot with less than 100 features selected. Requires rerunning glmnet, so we'll do it only once.

```{r}
set.seed(123)

glm.os.zoom = cv.glmnet(x = enet.gene, y = os, family = "cox", alpha = 0.5,df=100)
plot(glm.os.zoom)
```

```{r, include=F}
pdf(here("results", "survival", "model_os_gene_zoom.pdf"))
#glm.os.zoom = cv.glmnet(x = enet.gene, y = os, family = "cox", alpha = 0.5,df=100)
plot(glm.os.zoom)
dev.off()
```

#### Features

Number of features selected over 10 xval loops

```{r}
sapply(glm.os$features, nrow) %>% sort()
```

Recurring features in 10 xval loops

```{r}
recurring_features <- function(glm_results, anno_df = gx_annot){
  #Takes a list of fit objects where the coefficients are ensembl gene ids
  #Anno_df should be an annotation data frame that contains an ensembl_gene_id column
  
  feat = bind_rows(glm_results$features) %>%
    group_by(name) %>%
    summarise(n=n(), mean_beta = mean(value), sd_beta = sd(value)) %>%
    arrange(desc(n)) %>%
    left_join(.,gx_annot, by=c("name"="ensembl_gene_id")) 
  return(feat)
}
```


```{r}
glm.os.features = recurring_features(glm.os)
glm.os.features %>% head(30)
```

### OS genes, including clinical covariates

```{r, eval=F}
if(file.exists(file.path(resDir, "12_glm_os_clin.Rds")) == F | overwrite == T){
  print("Elastic Cox for overall survival, including clinical covariates...")
  start <- Sys.time()
  glm.os.clin <- nested.cox(x = enet.clin, y = os, s = "lambda.min", alpha = 0.5)
  end <- Sys.time()
  print(end-start)
  saveRDS(glm.os.clin, file.path(resDir,"12_glm_os_clin.Rds"))
}
```

```{r}
glm.os.clin <- readRDS(file.path(resDir,"12_glm_os_clin.Rds"))
```


#### Model plots

Plots of 10 cross-validation runs. Result is (unsurprisingly) similar to the gene-only overall survival model.

```{r, fig.width=8, fig.height=10}
par(mar=c(4,4,2,2))
par(mfrow=c(5,2))
lapply(glm.os.clin$fitplots, plot)
```


```{r, include=F}
pdf(here("results", "survival", "model_os_clin.pdf"), height = 10, width = 8)
par(mar=c(4,4,2,2))
par(mfrow=c(5,2))
lapply(glm.os.clin$fitplots, plot)
dev.off()
```

#### Features

Number of features selected over 10 xval loops

```{r}
sapply(glm.os.clin$features, nrow) %>% sort()
```

Recurring features in 10 xval loops

```{r}
glm.os.clin.features = recurring_features(glm.os.clin)

glm.os.clin.features %>% head(30)
```

Very similar to the model without clinical features. Surprising however is that stage is only selected as a feature in 2 out of 10 models, and the beta is relatively weak.

```{r}
glm.os.clin.features %>% 
  filter(!str_detect(name, "ENSG"))
```

## DRS/metastasis

Run in script 12, results loaded here.

### DRS genes as features

```{r, eval=F}
if(file.exists(file.path(resDir, "12_glm_drs_gene.Rds")) == F | overwrite == T){
  print("Elastic Cox for distant recurrence (metastasis), genes only...")
  start <- Sys.time()
  glm.drs <- nested.cox(x = enet.gene.drs, y = drs, s = "lambda.min", alpha = 0.5)
  end <- Sys.time()
  print(end-start)
  saveRDS(glm.drs, file.path(resDir,"12_glm_drs_gene.Rds"))
}
```

```{r}
glm.drs <- readRDS(file.path(resDir,"12_glm_drs_gene.Rds"))
```


#### Model plots

Plots of 10 cross-validation runs. Performance is fairly consitent below 100 transcripts, with little performance gained from 1 to ~60 features selected.

```{r, fig.width=8, fig.height=10}
par(mar=c(4,4,2,2))
par(mfrow=c(5,2))
lapply(glm.drs$fitplots, plot)
```

```{r, include=F}
pdf(here("results", "survival", "model_drs.pdf"), height = 10, width = 8)
par(mar=c(4,4,2,2))
par(mfrow=c(5,2))
lapply(glm.drs$fitplots, plot)
dev.off()
```

#### Features

Number of features selected over 10 xval loops

```{r}
sapply(glm.drs$features, nrow) %>% sort()
```

Recurring features in 10 xval loops. Is a bit more consistent than OS.

```{r}
glm.drs.features = recurring_features(glm.drs)
glm.drs.features %>% head(30)
```

### DRS genes, including clinical covariates

```{r, eval=F}
if(file.exists(file.path(resDir, "12_glm_drs_clin.Rds")) == F | overwrite == T){
  print("Elastic Cox for distant recurrence, including clinical covariates...")
  start <- Sys.time()
  glm.os.clin <- nested.cox(x = enet.clin, y = os, s = "lambda.min", alpha = 0.5)
  end <- Sys.time()
  print(end-start)
  saveRDS(glm.drs.clin, file.path(resDir,"12_glm_drs_clin.Rds"))
}
```

```{r}
glm.drs.clin <- readRDS(file.path(resDir,"12_glm_drs_clin.Rds"))
```


#### Model plots

Plots of 10 cross-validation runs. Result is (unsurprisingly) similar to the gene-only overall survival model.

```{r, fig.width=8, fig.height=10}
par(mar=c(4,4,2,2))
par(mfrow=c(5,2))
lapply(glm.drs.clin$fitplots, plot)
```

```{r, include=F}
pdf(here("results", "survival", "model_drs_clin.pdf"), height = 10, width = 8)
par(mar=c(4,4,2,2))
par(mfrow=c(5,2))
lapply(glm.drs.clin$fitplots, plot)
dev.off()

lapply(glm.os.clin$fitplots, plot)
```

#### Features

Number of features selected over 10 xval loops

```{r}
sapply(glm.drs.clin$features, nrow) %>% sort()
```

Recurring features in 10 xval loops

```{r}
glm.drs.clin.features = recurring_features(glm.drs.clin)

glm.drs.clin.features %>% head(30)
```

Very similar to the model without clinical features. Unlike overall survival, stage is much more important.

```{r}
glm.os.clin.features %>% 
  filter(!str_detect(name, "ENSG"))
```


Which genes are in common with all 4 models?

```{r}
tibble(ensembl_gene_id = Reduce(
  intersect, list(glm.os.features$name,glm.os.clin.features$name,
                  glm.drs.features$name, glm.drs.clin.features$name))) %>%
  left_join(., gx_annot, by = "ensembl_gene_id")
```

## Write results

There's very little difference between the gene only and gene + clinical covariates, but we'll save them all anyway.
enet.gene.drs = enet.gene[!(rownames(enet.gene) %in% met_at_diag),]
enet.clin.drs = enet.clin[!(rownames(enet.clin) %in% met_at_diag),]

```{r}
meta_enet <- tibble(
  Name = c("uni_enet_os",
           "uni_enet_drs",
           "multi_enet_os",
           "multi_enet_drs"),
  Type = c(rep("Genes only",2),
            rep("Genes plus clinical covariates",2)),
  Event = rep(c("overall survival", "distant recurrence/metastasis"), 2),
  Test = rep("Elastic net Cox regression", 4),
  Package = rep("glmnet", 4))
meta_enet

openxlsx::write.xlsx(list(description = meta_enet,
                          uni_enet_os = glm.os.features,
                          uni_enet_drs = glm.drs.features,
                          multi_enet_os = glm.os.clin.features,
                          multi_enet_drs = glm.drs.clin.features),
                     file = here("results", "survival", "12_elastic_cox_allgenes.xlsx"))
```



# Integrating results

There are two types of events being examined:

* Overall survival (OS)
* Distant recurrence (DRS)/metastasis

We have two major groups of results for both types of events:

* Genewise Cox models, which fit a Cox model to each gene separately
* Elastic net Cox models, which uses all genes as features and applies regularization to select the most relevant genes

For each of these, we have two types of design formulas: One which includes the clinical covariates and one which does not.

```{r}
covariates
```

## Define survival/metastasis groups

For heatmap annotations.

```{r}
#Surv(time = sd$months_overall_survival, event = sd$overall_survival) %>% as.character()
sd = sd %>% mutate(survival_group = case_when(
  overall_survival == 1 & months_overall_survival < 50 ~ "death_50mo",
  overall_survival == 1 & months_overall_survival < 100 ~ "death_100mo",  
  overall_survival == 1 & months_overall_survival < 150 ~ "death_150mo",
  overall_survival == 1 & months_overall_survival < 200 ~ "death_200mo",
  overall_survival == 1 & months_overall_survival < 250 ~ "death_200mo",
  overall_survival == 0 ~ "survived",
  TRUE ~ "no_data"
)) %>% select(sample_name, survival_group, months_overall_survival, overall_survival, everything())

rownames(sd) = sd$sample_name

head(sd)
```

```{r}
sd = sd %>% mutate(drs_group = case_when(
  distant_recurrence == 1 & months_to_drs < 50 ~ "met_50mo",
  distant_recurrence == 1 & months_to_drs < 100 ~ "met_100mo",  
  distant_recurrence == 1 & months_to_drs < 150 ~ "met_150mo",
  distant_recurrence == 1 & months_to_drs < 200 ~ "met_200mo",
  distant_recurrence == 1 & months_to_drs < 250 ~ "met_200mo",
  distant_recurrence == 0 ~ "no_metastasis",
  TRUE ~ "no_data"
)) %>% select(sample_name, drs_group, months_to_drs, distant_recurrence, everything())

rownames(sd) = sd$sample_name

head(sd)
```


## Overall survival

Only one gene is significant in the genewise Cox models for overall survival.

```{r}
filter(res_allgenes_multivar_surv, fdr<0.1)
filter(res_allgenes_univ_surv, fdr<0.1)
```

### Plot features x fdr

```{r}
glm.os.clin.features %>% filter(n > 1) %>%
  left_join(., select(res_allgenes_multivar_surv,fdr:ensembl_gene_id), by = c("name"="ensembl_gene_id")) %>%
  select(gene_name, n, fdr, everything()) %>%
  ggplot(aes(x = n, y = -log10(fdr), color = if_else(beta > 0, "beta > 0", "beta < 0"))) +
  geom_jitter(height = 0, width = 0.1, show.legend = F) +
  labs(color="Direction") +
  xlab("Feature selected out of 10 penalized elastic Cox models") +
  ylab("-log10(FDR) from genewise Cox model") +
  ggrepel::geom_text_repel(aes(label = ifelse(n > 2, gene_name, "")), show.legend = T) +
  geom_hline(yintercept=-log10(0.05), linetype="dashed", color="red") +
  geom_text(aes(0,-log10(0.05),label = "fdr 0.05", vjust = -1)) +
  geom_hline(yintercept=-log10(0.1), linetype="dashed", color="blue") +
  geom_text(aes(0,-log10(0.1),label = "fdr 0.1", vjust = -1)) +
  ggtitle("Genes associated with overall survival") 
```

```{r, include=F}
ggsave(here("results", "survival", "12_fdr_survival_genes.pdf"), height = 6, width = 8)
```


### Heatmap

Limit plot to those features that occur in at least 3 out of 10 models.

```{r, fig.width=8}
ann_df = sd[,c("study_group", "survival_group"), drop=F]

pheatmap(vsd[rownames(vsd) %in% filter(glm.os.clin.features, n > 2)$gene_name,],
         show_colnames = F, scale="row", annotation_col = ann_df,annotation_colors = list(study_group = study_colors[-5]),
         main = "Genes associated with survival") 
```

```{r, include=F}
pheatmap(vsd[rownames(vsd) %in% filter(glm.os.clin.features, n > 2)$gene_name,],
         show_colnames = F, scale="row", annotation_col = ann_df,annotation_colors = list(study_group = study_colors[-5]),
         main = "Genes associated with survival", filename = here("results", "survival", "12_hm_surv_genes.pdf")) 
```


## DRS/metastasis

Huge differences between multivariate and univariate genewise Cox models.

```{r}
filter(res_allgenes_multivar_dr, fdr<0.1)
filter(res_allgenes_univ_dr, fdr<0.1) %>% nrow()
```

### Plot features x fdr

For the sake of exploration, we plot the fdr from the univariate drs analysis, given that there's so many more significant hits compared to the multivariate analysis.

```{r}
glm.drs.clin.features %>% filter(n > 1) %>%
  left_join(., select(res_allgenes_univ_dr,fdr:ensembl_gene_id), by = c("name"="ensembl_gene_id")) %>%
  select(gene_name, n, fdr, everything()) %>%
  ggplot(aes(x = n, y = -log10(fdr), color = if_else(beta > 0, "beta > 0", "beta < 0"))) +
  geom_jitter(height = 0, width = 0.1, show.legend = F) +
  labs(color="Direction") +
  xlab("Feature selected out of 10 penalized elastic Cox models") +
  ylab("-log10(FDR) from genewise Cox model") +
  ggrepel::geom_text_repel(aes(label = ifelse(n > 4, gene_name, "")), show.legend = T) +
  geom_hline(yintercept=-log10(0.05), linetype="dashed", color="red") +
  geom_text(aes(0,-log10(0.05),label = "fdr 0.05", vjust = -1)) +
  geom_hline(yintercept=-log10(0.1), linetype="dashed", color="blue") +
  geom_text(aes(0,-log10(0.1),label = "fdr 0.1", vjust = -1)) +
  ggtitle("Genes associated with metastasis") 
```

```{r, include=F}
ggsave(here("results", "survival", "12_fdr_metastasis_genes.pdf"), height = 6, width = 8)
```


### Heatmap

Limit plot to those features that occur in at least 4 out of 10 models.

```{r, fig.width=8}
ann_df = sd[,c("study_group", "drs_group"), drop=F]

pheatmap(vsd[rownames(vsd) %in% filter(glm.drs.clin.features, n > 3)$gene_name,],
         show_colnames = F, scale="row", annotation_col = ann_df,annotation_colors = list(study_group = study_colors[-5]),
         main = "Genes associated with metastasis") 
```

```{r, include=F}
ann_df = sd[,c("study_group", "drs_group"), drop=F]

pheatmap(vsd[rownames(vsd) %in% filter(glm.drs.clin.features, n > 3)$gene_name,],
         show_colnames = F, scale="row", annotation_col = ann_df,annotation_colors = list(study_group = study_colors[-5]),
         main = "Genes associated with metastasis", filename = here("results", "survival", "12_hm_drs_genes.pdf")) 
```

# To be discussed: Predictions

Paraphrased from [this post](https://stats.stackexchange.com/questions/388770/cox-model-with-lasso-using-one-dataset-and-predicting-in-a-different-dataset) and confirmed by Misha:

With cox models, type = "link" gives the linear predictor. (Recap: The linear predictor is a linear sum of the effects of one or more explanatory variables). The right-hand side of the equation is called the linear structure. Type = response is essentially the exponential of the linear predictor, giving a relative risk of survival outcome. It's relative between samples, so if you want to get survival probability, a baseline measure must be calculated (comparable to intercept).

However, the Cox model itself cannot give you the S0, you need another method to estimate the S0, for example, fitting your covariate with beta into a coxph model with initial covariates and then estimate baseline with basehaz. See also: [Frailtypack](https://cran.r-project.org/web/packages/frailtypack/index.html) (R package)

```{r}
relrisk.df = sapply(glm.os$fitplots, function(x) glmnet::predict.cv.glmnet(x, 
                newx = enet.gene, s = "lambda.min", alpha=0.5, type="response")) %>%
  set_colnames(., paste("fitted.rel.risk",1:10, sep="_")) %>% as.data.frame() %>%
  set_rownames(rownames(enet.gene))

head(relrisk.df)
```

In intercept-only (zero feature) models, the relative risk is reported as 1 across all samples

```{r}
relrisk.df[,which(sapply(glm.os$features, nrow)==0)] %>% head()

relrisk.df <- relrisk.df[,-c(which(sapply(glm.os$features, nrow)==0))]
```

```{r, eval=F}
#Heatmap contains too many outliers to be informative
pheatmap(relrisk.df, annotation_row = sd[,"study_group", drop=F], show_rownames = F, scale="column")
```

Because the risk is relative between samples, we take the Z score centered on column

```{r}
z.relrisk = as.data.frame(scale(relrisk.df))

z.relrisk = rownames_to_column(z.relrisk, "sample_name") %>%
  gather(key = model, value="rel.risk", -sample_name)

head(z.relrisk)
```


## Plotting rel risk by survival

```{r}
relplot.df = coxdata %>% select(months_overall_survival, overall_survival, study_group) %>%
  rownames_to_column("sample_name") %>%
  mutate(death = if_else(overall_survival==1, T, F)) %>%
  left_join(., z.relrisk, by = "sample_name")

relplot.df %>% head(10)
```

```{r, include=F}
#Option1: ggpubr, unfortunately forces x to be discrete, making break setting screwy

relplot.df %>%
  ggerrorplot(.,x = "months_overall_survival", y = "rel.risk", color="death", shape="study_group") +
  ggtitle("Relationship between relative risk and survival") +
  #rotate_x_text(90) +
  theme_bw() %+replace%
    theme(axis.ticks = element_blank(), legend.background = element_blank(),
          legend.key = element_blank(), panel.background = element_blank(),
          panel.border = element_blank(), strip.background = element_blank(),
          plot.background = element_blank(), complete = TRUE)+
    theme(axis.text.x = element_text(angle=90, size = 8)) +
  #scale_x_continuous(breaks=seq(0, 250, by=10)) + #Doesn't work
  scale_x_discrete(breaks=seq(0, 250, by=10))

```



```{r, fig.width=8}
se <- function(x) sd(x)/sqrt(length(x))
lm_eqn <- function(df){
    m <- lm(mean.rel.risk ~ months_overall_survival, df);
    #eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
    #     list(a = format(unname(coef(m)[1]), digits = 2),
    #          b = format(unname(coef(m)[2]), digits = 2),
    #         r2 = format(summary(m)$r.squared, digits = 3)))
    r2 = format(summary(m)$r.squared, digits = 2)
    #as.character(as.expression(eq));
    as.character(r2);
}


erplot.df = relplot.df %>%
  group_by(sample_name, months_overall_survival,death, study_group) %>%
  summarise(mean.rel.risk = mean(rel.risk), se = se(rel.risk)) 

R2.death = lm_eqn(erplot.df[erplot.df$death==1,])
R2.surv = lm_eqn(erplot.df[erplot.df$death==0,])

gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
cols = gg_color_hue(2)

erplot.df %>%
  ggplot(aes(x = months_overall_survival, y = mean.rel.risk, color=death)) + #shape=study_group 
  geom_point(size=3) +
  geom_errorbar(aes(ymin=mean.rel.risk-se, ymax=mean.rel.risk+se), width=.2,
                 position=position_dodge(.9)) +
  ggtitle("Relationship between relative risk and survival") +
  geom_smooth(se=F, method="lm") +
  #geom_text(label = paste("R2 death:", R2.death), vjust = -1) +
  geom_text(x = 10, y = 0, label = paste("R2:", R2.surv,sep="\n"), parse = TRUE, color = cols[1], show.legend = F) +
  geom_text(x = 10, y = 2.0, label = paste("R2:", R2.death,sep="\n"), parse = TRUE, color = cols[2],show.legend = F) +
  #geom_text(x = 5, y = 1, label = "R2", parse = TRUE, color = "black",show.legend = F) +
  theme_minimal()


```

Same plot, but with a smoothed line:

```{r}
erplot.df %>%
  ggplot(aes(x = months_overall_survival, y = mean.rel.risk, color=death)) + #shape=study_group 
  geom_point(size=3) +
  geom_errorbar(aes(ymin=mean.rel.risk-se, ymax=mean.rel.risk+se), width=.2,
                 position=position_dodge(.9)) +
  ggtitle("Relationship between relative risk and survival") +
  geom_smooth(se=F,method="loess") +
  theme_minimal()


```



# Select genes of interest

Load the LRT results for plotting.

```{r}
#readxl::excel_sheets(here("results", "diffex", "06_LRT_allgenes.xlsx"))

lrt = readxl::read_excel(here("results", "diffex", "06_LRT_allgenes.xlsx"), sheet="repLRT_all")
head(lrt)
```

Modify beehive function for Cox results. Use fdr from univariate metastasis, since that's the analysis with more than just one gene below fdr < 0.05.

```{r, include=F}
filter(res_allgenes_univ_dr, fdr<0.05)
```


```{r}
plot_cox_beehive <- function(dds, description, ensembl_id, res_df, cox_df){
  p <- plot_gene_beehive(dds, res_df[res_df$ensembl_gene_id == ensembl_id,,drop=F])
  lrt_padj <- res_df[res_df$ensembl_gene_id == ensembl_id,]$padj
  cox <- cox_df[cox_df$ensembl_gene_id == ensembl_id, , drop=F]
  cox_padj = cox$fdr
  beta <- cox$beta
  gene <- cox$gene_name
  p <- p + ggtitle(paste0(gene, ", ", description, ", Cox fdr: ", round(cox_padj, 2),
                          ", beta: ", round(beta, 2), ", LRT padj: ", round(lrt_padj, 2)))
  return(p)
}
```


## [ALOX12B](https://www.genecards.org/cgi-bin/carddisp.pl?gene=ALOX12B)

>Non-heme iron-containing dioxygenase that catalyzes the stereo-specific peroxidation of free and esterified polyunsaturated fatty acids generating a spectrum of bioactive lipid mediators. Mainly converts arachidonic acid to (12R)-hydroperoxyeicosatetraenoic acid/(12R)-HPETE and minor stereoisomers. In the skin, acts upstream of ALOXE3 on the lineolate moiety of esterified omega-hydroxyacyl-sphingosine (EOS) ceramides to produce an epoxy-ketone derivative, a crucial step in the conjugation of omega-hydroxyceramide to membrane proteins. Therefore plays a crucial role in the synthesis of corneocytes lipid envelope and the establishment of the skin barrier to water loss. May also play a role in the regulation of the expression of airway mucins.

Associated with both overall survival and DRS.

```{r}
plot_cox_beehive(dds, description = "Multi OS", ensembl_id = "ENSG00000179477", res_df = lrt, cox_df =  res_allgenes_multivar_surv)
plot_cox_beehive(dds, description = "Multi DRS", ensembl_id = "ENSG00000179477", res_df = lrt, cox_df =  res_allgenes_multivar_dr)
```

More genes of interest: Both significant in the drs univariate model and have an fdr of under 0.2 in the lrt:

```{r}
goi = filter(res_allgenes_univ_dr, fdr<0.05) %>%
  #filter(gene_type == "protein_coding" & gene_name != "ALOX12B") %>%
  filter(gene_name != "ALOX12B") %>%
  pull(ensembl_gene_id)
filter(lrt, ensembl_gene_id %in% goi & padj < 0.2)
```

## [P2RY14](https://www.genecards.org/cgi-bin/carddisp.pl?gene=P2RY14)

>The product of this gene belongs to the family of G-protein coupled receptors, which contains several receptor subtypes with different pharmacological selectivity for various adenosine and uridine nucleotides. This receptor is a P2Y purinergic receptor for UDP-glucose and other UDP-sugars coupled to G-proteins. It has been implicated in extending the known immune system functions of P2Y receptors by participating in the regulation of the stem cell compartment, and it may also play a role in neuroimmune function.

```{r}
plot_cox_beehive(dds, description = "Uni DRS", ensembl_id = "ENSG00000174944", res_df = lrt, cox_df =  res_allgenes_univ_dr)
```

## [MPP5](https://www.genecards.org/cgi-bin/carddisp.pl?gene=MPP5&keywords=ENSG00000072415)

>Plays a role in tight junction biogenesis and in the establishment of cell polarity in epithelial cells (PubMed:16678097, PubMed:25385611). Also involved in adherens junction biogenesis by ensuring correct localization of the exocyst complex protein EXOC4/SEC8 which allows trafficking of adherens junction structural component CDH1 to the cell surface (By similarity). Plays a role through its interaction with CDH5 in vascular lumen formation and endothelial membrane polarity (PubMed:27466317). Required during embryonic and postnatal retinal development (By similarity). Required for the maintenance of cerebellar progenitor cells in an undifferentiated proliferative state, preventing premature differentiation, and is required for cerebellar histogenesis, fissure formation and cerebellar layer organization (By similarity). Plays a role in the radial and longitudinal extension of the myelin sheath in Schwann cells (By similarity). May modulate SC6A1/GAT1-mediated GABA uptake by stabilizing the transporter (By similarity). Plays a role in the T-cell receptor-mediated activation of NF-kappa-B (PubMed:21479189). Required for localization of EZR to the apical membrane of parietal cells and may play a role in the dynamic remodeling of the apical cytoskeleton (By similarity). Required for the normal polarized localization of the vesicular marker STX4 (By similarity). Required for the correct trafficking of the myelin proteins PMP22 and MAG (By similarity).

```{r}
plot_cox_beehive(dds, description = "Uni DRS", ensembl_id = "ENSG00000072415", res_df = lrt, cox_df =  res_allgenes_univ_dr)
```

## [ZSCAN4](https://www.genecards.org/cgi-bin/carddisp.pl?gene=ZSCAN4&keywords=ZSCAN4)	

>Embryonic stem (ES) cell-specific transcription factor required to regulate ES cell pluripotency. Binds telomeres and plays a key role in genomic stability in ES cells by regulating telomere elongation. Acts as an activator of spontaneous telomere sister chromatid exchange (T-SCE) and telomere elongation in undifferentiated ES cells


```{r}
plot_cox_beehive(dds, description = "Uni DRS", ensembl_id = "ENSG00000180532", res_df = lrt, cox_df =  res_allgenes_univ_dr)
```


## [FANCM](https://www.genecards.org/cgi-bin/carddisp.pl?gene=FANCM&keywords=FANCM)	

>DNA-dependent ATPase component of the Fanconi anemia (FA) core complex (PubMed:16116422). Required for the normal activation of the FA pathway, leading to monoubiquitination of the FANCI-FANCD2 complex in response to DNA damage, cellular resistance to DNA cross-linking drugs, and prevention of chromosomal breakage (PubMed:16116422, PubMed:19423727, PubMed:20347428, PubMed:20347429, PubMed:29231814). In complex with CENPS and CENPX, binds double-stranded DNA (dsDNA), fork-structured DNA (fsDNA) and Holliday junction substrates (PubMed:20347428, PubMed:20347429). Its ATP-dependent DNA branch migration activity can process branched DNA structures such as a movable replication fork. This activity is strongly stimulated in the presence of CENPS and CENPX (PubMed:20347429). In complex with FAAP24, efficiently binds to single-strand DNA (ssDNA), splayed-arm DNA, and 3'-flap substrates (PubMed:17289582). In vitro, on its own, strongly binds ssDNA oligomers and weakly fsDNA, but does not bind to dsDNA (PubMed:16116434).

```{r}
plot_cox_beehive(dds, description = "Uni DRS", ensembl_id = "ENSG00000187790", res_df = lrt, cox_df =  res_allgenes_univ_dr)
```


## Save data

Remove extremely large objects first (over 1GB memory)

```{r}
ls(pattern = "multivar_gene")
rm("multivar_gene_dr")
rm("multivar_gene_surv")

ls(pattern = "univ_gene")
rm("univ_gene_dr")
rm("univ_gene_surv")
```


```{r}
save.image(here("reports", "12_survival.RData"))
```

