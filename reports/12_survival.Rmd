---
title: "12_survival"
author: "Kat Moore"
date: "11/7/2019"
output: 
  html_notebook:
    toc: yes
    toc_float: yes
    toc_depth: 4
    highlight: tango
---

```{r}
rm(list = ls())
```

```{r, include=F}
#devtools::install_github('kevinblighe/RegParallel')
#source("https://bioconductor.org/biocLite.R")
#biocLite("GEOquery")
#library(GEOquery) #Example only
#library(Biobase) #Example only
#library(RegParallel) #Example only
library(DESeq2)
library(survival)
library(survminer)
library(pheatmap)
library(ComplexHeatmap)
library(RColorBrewer)
library(glmnet)
library(openxlsx)
library(ROCR)
library(caret)
library(tidyverse)
library(here)
library(ggpubr)
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Pre-process and load data

```{r}
source(here("src", "deseq_report_functions.R"))
```


```{r}
dds = readRDS(here("data/Rds/08_dds_inv_vs_rest_standard.Rds"))
gx_annot <- read_tsv(here("data/metadata/01_tx_annot.tsv"))
gx_annot = gx_annot %>% select(ensembl_gene_id = gene_id, gene_name, gene_type, description = gene_description) %>% distinct()
```

## Heatmap colors

Created in notebook 6

```{r}
all_colors = readRDS(here("data","Rds", "06_heatmap_colors.Rds"))
study_colors = all_colors$study_colors
pam_colors = all_colors$pam_colors
gene_colors = all_colors$gene_colors
```

Create data matrix with covariates from the sample data in the first few columns, then genes. Samples are rows.

## Prepare metadata

Covariates: grade, stage, molecular subtype, age at diagnosis and year of diagnosis (Also possibly therapy type)

```{r}
sd = as.data.frame(colData(dds)) %>%
  select(sample_name, death,
         years_overall_survival,
         months_of_followup,
         study_group, PAM50,
         grade, stage,
         inv_vs_rest, prbc_vs_rest,
         lac_vs_rest, nonprbc_vs_rest,
         year_of_diagnosis, age_at_diagnosis,
         overall_survival, months_overall_survival,
         distant_recurrence, months_to_drs,
         local_recurrence_free_survival, months_to_lrs)

#Unnecessary
#sd = sd %>% mutate(
#  grade = as.factor(grade),
#  stage = as.factor(stage),
#  overall_survival = as.factor(overall_survival),
#  distant_recurrence = as.factor(distant_recurrence),
#  local_recurrence_free_survival = as.factor(local_recurrence_free_survival))

head(sd)
```
Exclude samples for which there has been less than 20 months of follow up, unless the reason for the lack of follow up is that the patient passed away due to disease (and not an accident or suicide).

follow_up > 20 | death == 1


```{r, collapse=T}
print(paste("Started with", nrow(sd), "samples"))

print("Samples lost due to lack of survival information:")
nrow(sd %>% filter(is.na(death)))
excluded = sd %>% filter(is.na(death)) %>%
  mutate(reason = "no_survival_data")

print("Samples excluded due to patient death unrelated to disease")
print(nrow(sd %>% filter(! death %in% c(NA, "due to disease", "no"))))
excluded = bind_rows(excluded,
                     mutate(filter(sd, !death %in% c(NA, "due to disease", "no")),
                            reason = "unrelated_death")
                     )
print("Samples due to insufficient follow up")
nrow(sd %>% filter(months_of_followup < 20 & death != "due to disease"))

excluded = bind_rows(excluded,
                     mutate(filter(sd, months_of_followup < 20 & !death == "due to disease"),
                            reason = "insufficient_followup"))

print("Samples with 999 (unknown) years of overall survival")
nrow(sd %>% filter(years_overall_survival == 999))

excluded = bind_rows(excluded,
                     mutate(filter(sd, years_overall_survival == 999),
                            reason = "unknown_survival_years"))

metadata = sd %>% filter(!is.na(death)) %>%
  filter(death != "other cause") %>%
  filter(years_overall_survival != 999) %>%
  filter(months_of_followup >= 20 | death == "due to disease")

print(paste(nrow(metadata), "samples remaining post filtering"))

stopifnot(nrow(filter(metadata,rowSums(is.na(metadata)) > 0)) == 0)
```

## Prepare gene data

The author of the RegParallel packages [argues](https://www.biostars.org/p/344233/#360782) for using VSD, Rlog, or log(cpm) transformations prior to fitting the Cox model.

Intuitively it seems that VSD may overestimate the important of some lowly expressed genes. Try with the log cpm approach first.

```{r}
#fpm (fragments per million) is equivalent to cpm from edgeR
mat = t(log2(fpm(dds, robust=T) + 0.5))

#Exclude those samples which were also excluded from the metadata prep
mat = mat[rownames(mat) %in% metadata$sample_name,]
stopifnot(identical(rownames(mat), metadata$sample_name))
```

Combine into single dataframe for Cox

```{r}
coxdata = cbind(metadata, mat)

head(coxdata)
```

# Basic survival curves

## PPBC

Lactation shows the worst prognosis, followed by involution.

```{r, fig.width = 8}
km_ppbc = survfit(Surv(time=months_overall_survival, event=overall_survival) ~ study_group, data = coxdata) %>% 
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = "OS: All samples with adequate data (n = 177)",
    #linetype = "strata",
    pval = T,
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_ppbc$plot #Avoids printing a blank plot
```

```{r}
table(coxdata$death, coxdata$study_group)
```


```{r, echo=F, include=F}
resDir = here("results", "survival")
dir.create(resDir, showWarnings = F)

pdf(file.path(resDir, "12_km_ppbc.pdf"), width = 8, height = 6)
print(km_ppbc$plot, newpage=F)
dev.off()
```

Survdiff implements the log-rank test, which compares one or more curves vs the null hypothesis that there is no difference in survival between the curves. The log-rank statistic is chi-square distributed.

A comparison between all groups is near but not quite significant.

```{r}
survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ study_group, data = coxdata)
```

Pairwise log-rank tests show that none of the individual pairings are significant, although ppbc_lac vs non-prbc and prbc comes close.

```{r}
pairwise_survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ study_group, data = coxdata)
```

## PAM50

PAM50 shows no significant variance by molecular subtype.

```{r}
km_pam50 = 
survfit(Surv(time=months_overall_survival, event=overall_survival) ~ PAM50, data = coxdata) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = "OS: All samples with adequate data (n = 177)",
    pval = T,
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_pam50$plot
```

```{r, echo=F, include=F}
pdf(file.path(resDir, "12_km_pam50.pdf"), width = 8, height=6)
print(km_pam50$plot)
dev.off()
```

```{r}
table(coxdata$death, coxdata$PAM50)
```



Log-rank test for PAM50. Basal generally has a worse than expected outcome, consistent with the literature. The others are almost exactly matched with expected.

```{r}
survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ PAM50, data = coxdata)
```

Pairwise log-rank tests demonstrate that no pairing is remotely significant.

```{r}
pairwise_survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ PAM50, data = coxdata)
```

# Basic DRS curves

## PPBC

Just like OS, lactation shows the worst prognosis, followed by involution. But non-prbc is closer behind.

```{r, fig.width = 8}
drs_ppbc = survfit(Surv(time=months_to_drs, event=distant_recurrence) ~ study_group, data = coxdata) %>% 
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "DRS probability",
    title = "DRS: All samples with adequate data (n = 177)",
    #linetype = "strata",
    pval = T,
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

drs_ppbc$plot #Avoids printing a blank plot
```

```{r}
table(coxdata$distant_recurrence, coxdata$study_group)
```


```{r, echo=F, include=F}
resDir = here("results", "survival")
dir.create(resDir, showWarnings = F)

pdf(file.path(resDir, "12_drs_ppbc.pdf"), width = 8, height = 6)
print(drs_ppbc$plot, newpage=F)
dev.off()
```

A comparison between all groups is not significant.

```{r}
survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ study_group, data = coxdata)
```

Pairwise log-rank tests show that none of the individual pairings are at or near significance.

```{r}
pairwise_survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ study_group, data = coxdata)
```

## PAM50

PAM50 shows no significant variance by molecular subtype.

```{r}
drs_pam50 = 
survfit(Surv(time=months_to_drs, event=distant_recurrence) ~ PAM50, data = coxdata) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "DRS probability",
    title = "DRS: All samples with adequate data (n = 177)",
    pval = T,
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

drs_pam50$plot
```

```{r, echo=F, include=F}
pdf(file.path(resDir, "12_drs_pam50.pdf"), width = 8, height=6)
print(drs_pam50$plot)
dev.off()
```

```{r}
table(coxdata$distant_recurrence, coxdata$PAM50)
```

Log-rank test for PAM50 is similar to OS. Basal generally has a worse than expected outcome,the others match approximately with expected.

```{r}
survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ PAM50, data = coxdata)
```

Pairwise log-rank tests demonstrate that no pairing is remotely significant.

```{r}
pairwise_survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ PAM50, data = coxdata)
```

# Univariate Cox

## Study gorup

Non-prbc (nulliparous) is the reference group. A positive coefficient indicates an increased risk vs the reference, whereas a negative coefficient indicates a comparatively better prognosis vs the reference. The exponentiated coefficient exp(coef) is equivalent to the hazard ratio.

    HR = 1: No effect
    HR < 1: Reduction in the hazard
    HR > 1: Increase in Hazard

Lac and inv both have higher risk than non-prbc, but only lac is significant. Prbc has a lower risk than non-prbc.

```{r}
cox.ppbc <- coxph(Surv(time=months_overall_survival, event=overall_survival) ~ study_group, data = coxdata)
summary(cox.ppbc)
```

## PAM50

Congruent with the Kaplan-Meijer, no PAM50 group is significantly better or worse than the rest.

```{r}
cox.pam <- coxph(Surv(time=months_overall_survival, event=overall_survival) ~ PAM50, data = coxdata)
summary(cox.pam)
```

## Sequential univariate analysis of other covariate

Of the remaining covariates, only stage is significant.

```{r}
covariates <- c("age_at_diagnosis", "year_of_diagnosis","stage","grade")
res.simple.univ <- sapply(
  covariates,function(x) as.formula(paste('Surv(time=months_overall_survival, event=overall_survival)~', x))) %>%
  lapply(., function(x){coxph(x, data = coxdata)}) %>%
  lapply(.,
                       function(x){ 
                          x <- summary(x)
                          p.value<-signif(x$wald["pvalue"], digits=2)
                          wald.test<-signif(x$wald["test"], digits=2)
                          beta<-signif(x$coef[1], digits=2);#coeficient beta
                          HR <-signif(x$coef[2], digits=2);#exp(beta)
                          HR.confint.lower <- signif(x$conf.int[,"lower .95"], 2)
                          HR.confint.upper <- signif(x$conf.int[,"upper .95"],2)
                          HR <- paste0(HR, " (", 
                                       HR.confint.lower, "-", HR.confint.upper, ")")
                          res<-c(beta, HR, wald.test, p.value)
                          names(res)<-c("beta", "HR (95% CI for HR)", "wald.test", 
                                        "p.value")
                          return(res)
                          #return(exp(cbind(coef(x),confint(x))))
                         })
res.simple.univ <- t(as.data.frame(res.simple.univ, check.names = FALSE))
as.data.frame(res.simple.univ)
```

Distribution of stage over the study groups. Note that lactation has no patients in stage 1, which may contribute to the poorer prognosis in that group.

```{r}
table(coxdata$stage, coxdata$study_group)
```

## Heatmap cancer stage

```{r}
#par(mfrow=c(1,2))
pheatmap(as.matrix(table(coxdata$stage, coxdata$study_group)),
         scale="none", 
         display_numbers = T,
         number_format = "%.0f",
         cluster_rows = F, cluster_cols = F,
         main = "Study group by stage")

pheatmap(as.matrix(table(coxdata$stage, coxdata$study_group)),
         scale="column", 
         display_numbers = T,
         number_format = "%.2f",
         cluster_rows = F, cluster_cols = F,
         main = "Study group by stage, scaled by group")
```


```{r}
chisq.test(table(coxdata$stage, coxdata$study_group))
```



# Multivariate Cox

## All covariates

Including all clinical covariates, 11 total levels.

The LRT, Wald and logrank tests are all below 0.05. These tests evaluate the null hypothesis that the beta for every covariate is 0. The result indicates that the model overall is significant.

For increased risk, stage is significant at p < 0.001 and HR 2.6, while both involution and lactation are near significance with p < 0.1 and HR 2.4 and 3.2, respectively.

Her2 and LumB show significantly decreased risk at p < 0.05 and HRs 0.2 and 0.41, resepctively.

```{r}
clin.cov.cox <- coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis + year_of_diagnosis + grade + stage + PAM50 + study_group,
  data = coxdata)
summary(clin.cov.cox)
```

## Significant covariates

If limited to only those covariates which were significant in the univariate analysis, the results are similar. Most of the PAM50 comparisons are positively prognostic compared to basal at p < 0.1. Involution remains significant at p < 0.1, but lactation drifts out of the significant range.

```{r}
select.clin.cov.cox <- coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~  stage + PAM50 + study_group,
  data = coxdata)
summary(select.clin.cov.cox)
```

## Multivariate plot for study group

Estimate the impact of study group in the multivariate model. Requires constructing a new data frame with one row for each value of the covariate of interest; the other covariates are fixed to their average values (if they are continuous variables) or to their lowest level (if they are discrete variables).

There are comparatively few normal subtypes, so we will ignore it for this purpose.

```{r}
table(coxdata$PAM50, coxdata$study_group)
```

```{r}
study_df = coxdata %>%
  group_by(study_group) %>%
  summarize(age_at_diagnosis = mean(age_at_diagnosis),
            year_of_diagnosis = mean(year_of_diagnosis),
            grade = mean(grade),
            stage = mean(stage))

#Order: non_prbc, inv, lac, prbc
study_df$PAM50 = c("Her2", "Basal", "LumA", "LumB")
```

This data frame is passed to survfit() via the newdata argument:

```{r, fig.width=9, fig.height=6}
#survfit(clin.cov.cox, newdata = study_df)
plot.clin.cov.cox <- ggsurvplot(survfit(clin.cov.cox, newdata = study_df), conf.int = TRUE,
           legend.labs=c("non_prbc", "ppbc_inv", "ppbc_lac", "prbc"),
           ggtheme = theme_minimal(), data=coxdata,
           title = "Survival ~ age_at_diagnosis + year_of_diagnosis + grade + stage + PAM50 + study_group")
plot.clin.cov.cox$plot
```

```{r, echo=F, include=F}
pdf(file.path(resDir, "12_curve_multivariate_ppbc.pdf"),width = 9, height = 6)
print(plot.clin.cov.cox$plot)
dev.off()
```


# Independent genewise Cox regression

```{r}
extract_genewise_cox_results <- function(cox_models, type){
  
  #Cox models generated as follows:
  #gene_formulas <- sapply(gene_vector,function(x) as.formula(paste('Surv(time, event)~', x)))
  #cox_models <- lapply(gene_formulas, function(x){coxph(x, data = coxdata)})
  
  stopifnot(type %in% c("univariate", "multivariate"))
  
  if(type == "univariate"){
    univ_gene_results <- lapply(cox_models,
                                function(x){ 
                                  x <- summary(x)
                                  p.value<-signif(x$wald["pvalue"], digits=2)
                                  #wald.test<-signif(x$wald["test"], digits=2) #Unnecessary
                                  beta<-signif(x$coef[1], digits=2);#coeficient beta
                                  HR <-signif(x$coef[2], digits=2);#exp(beta)
                                  HR.confint.lower <- signif(x$conf.int[,"lower .95"], 2)
                                  HR.confint.upper <- signif(x$conf.int[,"upper .95"],2)
                                  HR <- paste0(HR, " (", 
                                               HR.confint.lower, "-", HR.confint.upper, ")")
                                  res<-c(beta, HR,
                                         #wald.test,
                                         p.value)
                                  names(res)<-c("beta", "HR (95% CI for HR)", #"wald.test", 
                                                "p.value")
                                  return(res)
                                  #return(exp(cbind(coef(x),confint(x))))
                                })
    
    res_df <- t(as.data.frame(univ_gene_results, check.names = FALSE))
  }
  
  if(type == "multivariate"){
    multivar_gene_results <- lapply(cox_models,
                                    function(x){
                                      x <- summary(x)
                                      #Drop the other formula elements
                                      coefs <- as.data.frame(x$coefficients)
                                      coefs <- rownames_to_column(coefs, "ensembl_gene_id")
                                      gene = tail(coefs$ensembl_gene_id,1)
                                      coefs <- coefs[coefs$ensembl_gene_id==gene, , drop=F]
                                      colnames(coefs) <- c("ensembl_gene_id", "beta", "HR", "se(beta)", "z", "p.value")
                          
                                      #Extract p val and stats for gene of interest
                                      p.value<-signif(coefs$p.value, digits = 2)
                                      beta<-signif(coefs$beta, digits=2);#coeficient beta
                                      HR <-signif(coefs$HR, digits=2);#exp(beta)
                          
                                      #Do the same for conf intervals
                                      conf.int = rownames_to_column(as.data.frame(x$conf.int), "ensembl_gene_id")
                                      conf.int = conf.int[conf.int$ensembl_gene_id==gene, , drop=F]
                                      HR.confint.lower <- signif(conf.int[,"lower .95"], 2)
                                      HR.confint.upper <- signif(conf.int[,"upper .95"],2)
                                      HR <- paste0(HR, " (", 
                                                   HR.confint.lower, "-", HR.confint.upper, ")")
                                      res<-c(beta, HR, p.value)
                                      names(res)<-c("beta", "HR (95% CI for HR)","p.value")
                                      return(res)
                                      })
    
    res_df <- t(as.data.frame(multivar_gene_results, check.names = FALSE))
  }
  
  df = as.data.frame(res_df) %>%
      rownames_to_column("ensembl_gene_id") %>%
      left_join(., gx_annot,by="ensembl_gene_id") %>%
      mutate(p.value = as.numeric(as.character(p.value)),
             beta = as.numeric(as.character(beta))) %>%
      select(gene_name, p.value, everything()) %>%
      arrange(p.value)
  
  return(df)
}

```

```{r}
genewise_cox <- function(gene_list, time, event, data = coxdata, type, show_runtime=T){
  stopifnot(type %in% c("univariate", "multivariate"))
  stopifnot(time %in% colnames(data))
  stopifnot(event %in% colnames(data))
  
  start <- Sys.time()
  
  formula = paste0('Surv(time=',time,', event=',event,')~')
  
  if(type == "multivariate"){
    formula = paste0(formula,'age_at_diagnosis+year_of_diagnosis+stage+grade+PAM50+')
    formula = 'Surv(time=months_overall_survival, event=overall_survival)~age_at_diagnosis+year_of_diagnosis+stage+grade+PAM50+'
  }
  
  gene_formulas <- sapply(gene_list, function(x) as.formula(paste(formula, x)))
  gene_models <- lapply(gene_formulas, function(x){coxph(x, data = data)})
  res <- extract_genewise_cox_results(gene_models, type=type)
  end <- Sys.time()
  
  if(show_runtime){print(end-start)}
  return(res)
}

```

# Overall survival: involution vs rest

Significant genes in the Wald test involution vs all other groups, as described in notebook 8.

```{r}
#excel_sheets(here("results","diffex", "08_one_vs_rest_sig_genes.xlsx"))
sig_inv_rest = readxl::read_excel(here("results","diffex", "08_one_vs_rest_sig_genes.xlsx"),sheet="sig_rep_inv_rest" )
#head(sig_inv_rest)

stopifnot(sum(duplicated(sig_inv_rest$ensembl_gene_id))==0)
```

## Univariate Cox by gene


```{r}
res_inv_univ_surv <- genewise_cox(sig_inv_rest$ensembl_gene_id, coxdata,
                                  time="months_overall_survival",
                                  event="overall_survival",
                                  type="univariate")
```

With only 51 genes significant for involution vs rest, we can page through all of them.

```{r}
res_inv_univ_surv
```

Genes significantly associated with a negative outcome:

(None)

```{r}
res_inv_univ_surv %>% filter(p.value < 0.1 & beta > 0)
```

Genes significantly associated with a positive outcome:

```{r}
res_inv_univ_surv %>% filter(p.value < 0.1 & beta < 0)
```

## Multivariate Cox by gene

Using all clinical covariates (except study group)

```{r}
res_inv_multivar_surv = genewise_cox(sig_inv_rest$ensembl_gene_id, coxdata,
                                  time="months_overall_survival",
                                  event="overall_survival",
                                  type="multivariate")
```

```{r}
res_inv_multivar_surv %>% arrange(p.value)
```


Genes significantly associated with a negative outcome:

(None)

```{r}
res_inv_multivar_surv %>% filter(p.value < 0.1 & beta > 0)
```

Genes significantly associated with a positive outcome:

```{r}
res_inv_multivar_surv %>% filter(p.value < 0.1 & beta < 0)
```

Overlap between the univariate and multivariate models:

```{r}
intersect(pull(filter(res_inv_univ_surv, p.value < 0.1),gene_name),
          pull(filter(res_inv_multivar_surv, p.value < 0.1),gene_name))
```



# Metastasis/DR: involution vs rest

distant_recurrence = metastasis, including those which were metastatic at diagnosis. These are those that were metastatic at diagnosis.

Some samples have months_to_drs = 0

```{r}
colData(dds) %>% as.data.frame() %>%
  filter(months_to_drs == 0) %>% select(sample_name, months_to_drs, metastasis_at_diagnosis)

met_at_diag = colData(dds) %>% as.data.frame() %>%
  filter(months_to_drs == 0) %>% select(sample_name, months_to_drs, metastasis_at_diagnosis) %>%
  pull(sample_name)
```


## Univariate Cox by gene

```{r}
res_inv_univ_dr = genewise_cox(sig_inv_rest$ensembl_gene_id, coxdata,
                                  time="months_to_drs",
                                  event="distant_recurrence",
                                  type="univariate")
```

Page through results

```{r}
res_inv_univ_dr
```

Genes significantly associated with a negative outcome:

(Still none)

```{r}
res_inv_univ_dr %>% filter(p.value < 0.1 & beta > 0)
```

Genes significantly associated with a positive outcome:

```{r}
res_inv_univ_dr %>% filter(p.value < 0.1 & beta < 0)
```

## Multivariate Cox by gene

Using all clinical covariates (except study group) for metastasis/distant recurrence.

```{r}
res_inv_multivar_dr = genewise_cox(sig_inv_rest$ensembl_gene_id, coxdata,
                                  time="months_to_drs",
                                  event="distant_recurrence",
                                  type="multivariate")
```


Genes significantly associated with a negative outcome:

(None)

```{r}
res_inv_multivar_dr %>% filter(p.value < 0.1 & beta > 0)
```

Genes significantly associated with a positive outcome:

```{r}
res_inv_multivar_dr %>% filter(p.value < 0.1 & beta < 0)
```

Overlap between the univariate and multivariate models:

```{r}
intersect(pull(filter(res_inv_univ_dr, p.value < 0.1),gene_name),
          pull(filter(res_inv_multivar_dr, p.value < 0.1),gene_name))
```


## Write results: inv vs rest

```{r, warning=F}
meta_sig_inv <- tibble(
  Name = c("input_diffex",
           "univ_cox_surv",
           "univ_cox_dr",
           "multi_cox_surv",
           "multi_cox_dr",
           "metadata"),
  Type = c("Significant genes from comparison involution vs rest",
            rep("Univariate",2),
            rep("Multivariate",2),
           "sample metadata"),
  Formula = c("~batch+PAM50+inv_vs_rest",
              "Surv(time=months_overall_survival,event=overall_survival)~gene",
              "Surv(time=months_to_drs,event=distant_recurrence)~gene",
              "Surv(time=months_overall_survival,event=overall_survival)~age_at_diagnosis+year_of_diagnosis+stage+grade+PAM50+gene",
              "Surv(time=months_to_drs,event=distant_recurrence)~age_at_diagnosis+year_of_diagnosis+stage+grade+PAM50+gene",
              NA),
  Package = c("DESeq2", rep("survival/survminer",4), NA),
  Test = c("Diffex/Wald", "Cox survival", "Cox metatasis", "Cox survival", "Cox metatasis", NA))

#head(meta_sig_inv)
openxlsx::write.xlsx(list(description = meta_sig_inv,
                          univ_cox_surv = res_inv_univ_surv,
                          univ_cox_dr = res_inv_univ_dr,
                          multi_cox_surv = res_inv_multivar_surv,
                          multi_cox_dr = res_inv_multivar_dr,
                          input_diffex = sig_inv_rest,
                          metadata = as.data.frame(colData(dds))),
                     file = here("results", "survival", "12_cox_inv_vs_rest_genes.xlsx"))
```


# All genes: overall survival

```{r}
resDir = here("data", "Rds")
```


Within coxdata, gene names start at position 21

```{r, include=F}
colnames(coxdata)[20:23]
```

## Multivariate survival

Run in script 12, results loaded here. Approx ~30 min runtime.

```{r, eval=F}
start <- Sys.time()
multivar_gene_formulas <- sapply(
  colnames(coxdata)[21:ncol(coxdata)],
  function(x) as.formula(
    paste(
      'Surv(time=months_overall_survival, event=overall_survival)~age_at_diagnosis+year_of_diagnosis+stage+grade+PAM50+',
      x)))
                        
multivar_gene_models <- lapply(multivar_gene_formulas, function(x){coxph(x, data = coxdata)})
end <- Sys.time()
end-start
saveRDS(multivar_gene_models, file=file.path(resDir, "12_allgenes_multivar_surv.Rds"))
```

>Time difference of 30.01901 mins

```{r}
multivar_gene_surv <- readRDS(file=here("data","Rds", "12_allgenes_multivar_surv.Rds"))
```

With ~30K genes, we'll need to apply multiple testing correction.

```{r}
start <- Sys.time()
res_allgenes_multivar_surv <- extract_genewise_cox_results(cox_models = multivar_gene_surv,
                                                      type = "multivariate") %>%
  mutate(fdr = p.adjust(p.value, method = "fdr")) %>%
  select(gene_name, fdr, beta, `HR (95% CI for HR)`, everything())

end <- Sys.time()

print(end-start)
```

Top 30 most significant results.

```{r}
head(res_allgenes_multivar_surv, 30)
```


### Correlation poor prognosis

Higher gene expression = worse prognosis

Using a generous fdr threshold of 0.2:

```{r}
print(paste("Number of genes negatively associated with survival, fdr < 0.2:",
      nrow(res_allgenes_multivar_surv %>% filter(beta > 0 & fdr < 0.2))))

res_allgenes_multivar_surv %>% filter(beta > 0 & fdr < 0.2) %>%
  select(description, gene_name, everything())
```

Without multiple testing correction (just for thoroughness):

```{r}
print(paste("Number of genes negatively associated with survival, pval < 0.01:",
      nrow(res_allgenes_multivar_surv %>% filter(beta > 0 & p.value < 0.01))))
res_allgenes_multivar_surv %>% filter(beta > 0 & p.value < 0.01) %>%
  select(description, gene_name, everything()) %>% head(20)
```

### Correlation good prognosis

Higher gene expression = better prognosis

Generous fdr cutoff of 0.2:

```{r}
print(paste("Number of genes positively associated with survival, fdr < 0.2:",
      nrow(res_allgenes_multivar_surv %>% filter(beta < 0 & fdr < 0.2))))
res_allgenes_multivar_surv %>% filter(beta < 0 & fdr < 0.2) %>%
  select(description, gene_name, everything())
```

For thorougness, based on p val alone:

```{r}
print(paste("Number of genes positively associated with survival, pval < 0.01:",
      nrow(res_allgenes_multivar_surv %>% filter(beta < 0 & p.value < 0.01))))
res_allgenes_multivar_surv %>% filter(beta > 0 & p.value < 0.01) %>%
  select(description, gene_name, everything()) %>% head(20)
```

## Univariate survival

```{r, eval=F}
start <- Sys.time()
univ_gene_formulas <- sapply(
  colnames(coxdata)[21:ncol(coxdata)],
  function(x) as.formula(
    paste(
      'Surv(time=months_overall_survival, event=overall_survival)~',
      x)))

univ_gene_models <- lapply(univ_gene_formulas, function(x){coxph(x, data = coxdata)})
end <- Sys.time()
print(end-start)
```

>Warning messages:
1: In fitter(X, Y, strats, offset, init, control, weights = weights,  :
  Loglik converged before variable  1 ; coefficient may be infinite. 
2: In fitter(X, Y, strats, offset, init, control, weights = weights,  :
  Loglik converged before variable  1 ; coefficient may be infinite. 
3: In fitter(X, Y, strats, offset, init, control, weights = weights,  :
  Loglik converged before variable  1 ; coefficient may be infinite. 
Time difference of 29.6996 mins

```{r}
univ_gene_surv <- readRDS(here("data", "Rds", "12_allgenes_univ_surv.Rds"))
```

With ~30K genes, we'll need to apply multiple testing correction.

```{r}
start <- Sys.time()
res_allgenes_univ_surv <- extract_genewise_cox_results(cox_models = univ_gene_surv,
                                                      type = "univariate") %>%
  mutate(fdr = p.adjust(p.value, method = "fdr")) %>%
  select(gene_name, fdr, beta, `HR (95% CI for HR)`, everything())

end <- Sys.time()

print(end-start)
```

Top 30 most significant results.

```{r}
head(res_allgenes_univ_surv, 30)
```


### Poor prognosis

Higher gene expression = worse prognosis

Using a generous fdr threshold of 0.2:

```{r}
print(paste("Number of genes negatively associated with survival, fdr < 0.2:",
      nrow(res_allgenes_univ_surv %>% filter(beta > 0 & fdr < 0.2))))

res_allgenes_univ_surv %>% filter(beta > 0 & fdr < 0.2) %>%
  select(description, gene_name, everything())
```

Without multiple testing correction (just for thoroughness):

```{r}
print(paste("Number of genes negatively associated with survival, pval < 0.01:",
      nrow(res_allgenes_univ_surv %>% filter(beta > 0 & p.value < 0.01))))
res_allgenes_univ_surv %>% filter(beta > 0 & p.value < 0.01) %>%
  select(description, gene_name, everything()) %>% head(20)
```

### Good prognosis

Higher gene expression = better prognosis

At FDR < 0.2, there is nothing. For exploration purposes, an even more generous fdr of 0.3

```{r}
print(paste("Number of genes positively associated with survival, fdr < 0.3:",
      nrow(res_allgenes_univ_surv %>% filter(beta < 0 & fdr < 0.3))))
res_allgenes_univ_surv %>% filter(beta < 0 & fdr < 0.3) %>%
  select(description, gene_name, everything())
```

For thorougness, based on p val alone:

```{r}
print(paste("Number of genes positively associated with survival, pval < 0.01:",
      nrow(res_allgenes_univ_surv %>% filter(beta < 0 & p.value < 0.01))))
res_allgenes_univ_surv %>% filter(beta > 0 & p.value < 0.01) %>%
  select(description, gene_name, everything()) %>% head(20)
```


# All genes: Metastasis/DR

distant_recurrence = metastasis, including those which were metastatic at diagnosis

```{r}
print("Distant_recurrence x metastasis at diagnosis:")
print(table(colData(dds)$distant_recurrence, colData(dds)$metastasis_at_diagnosis))
```

## Multivariate DR

Run in script 12, with results loaded ex post facto.

```{r, eval=F}
if(file.exists(file.path(resDir, "12_allgenes_multivar_dr.Rds")) == F | overwrite == T){
  print("Starting multivariate analysis for distant recurrence")
  start <- Sys.time()
  multivar_gene_formulas <- sapply(
    colnames(coxdata)[21:ncol(coxdata)],
    function(x) as.formula(
      paste(
        'Surv(time=months_to_drs, event=distant_recurrence)~age_at_diagnosis+year_of_diagnosis+stage+grade+PAM50+',
        x)))

  multivar_gene_models <- lapply(multivar_gene_formulas, function(x){coxph(x, data = coxdata)})
  end <- Sys.time()
  print(end-start)

  saveRDS(multivar_gene_models, file=file.path(resDir, "12_allgenes_multivar_dr.Rds"))
}
```

>Time difference of 31.40221 mins
Warning messages:
1: In fitter(X, Y, strats, offset, init, control, weights = weights,  :
  Loglik converged before variable  4 ; coefficient may be infinite. 
2: In fitter(X, Y, strats, offset, init, control, weights = weights,  :
  Loglik converged before variable  4 ; coefficient may be infinite. 

```{r}
multivar_gene_dr = readRDS(file.path(resDir, "12_allgenes_multivar_dr.Rds"))
```

With ~30K genes, we'll need to apply multiple testing correction.

```{r}
start <- Sys.time()
res_allgenes_multivar_dr <- extract_genewise_cox_results(cox_models = multivar_gene_dr,
                                                      type = "multivariate") %>%
  mutate(fdr = p.adjust(p.value, method = "fdr")) %>%
  select(gene_name, fdr, beta, `HR (95% CI for HR)`, everything())

end <- Sys.time()

print(end-start)
```

Top 30 most significant results.

```{r}
head(res_allgenes_multivar_dr, 30)
```


### Poor prognosis

Higher gene expression = worse prognosis

Using a generous fdr threshold of 0.2.

Now we find a few things!

```{r}
print(paste("Number of genes negatively associated with metastasis, fdr < 0.2:",
      nrow(res_allgenes_multivar_dr %>% filter(beta > 0 & fdr < 0.2))))

res_allgenes_multivar_dr %>% filter(beta > 0 & fdr < 0.2) %>%
  select(description, gene_name, everything())
```

Without multiple testing correction (just for thoroughness):

```{r}
print(paste("Number of genes negatively associated with metastasis, pval < 0.01:",
      nrow(res_allgenes_multivar_dr %>% filter(beta > 0 & p.value < 0.01))))
#res_allgenes_multivar_dr %>% filter(beta > 0 & p.value < 0.01) %>%
#  select(description, gene_name, everything()) %>% head(20)
```

### Good prognosis

Higher gene expression = better prognosis

Generous fdr cutoff of 0.2:

Foxp3 and Stat5a are there!

```{r}
print(paste("Number of genes positively associated with metastasis, fdr < 0.2:",
      nrow(res_allgenes_multivar_dr %>% filter(beta < 0 & fdr < 0.2))))
res_allgenes_multivar_dr %>% filter(beta < 0 & fdr < 0.2) %>%
  select(description, gene_name, everything())
```

For thorougness, based on p val alone:

```{r}
print(paste("Number of genes positively associated with metastasis, pval < 0.01:",
      nrow(res_allgenes_multivar_dr %>% filter(beta < 0 & p.value < 0.01))))
#res_allgenes_multivar_dr %>% filter(beta > 0 & p.value < 0.01) %>%
#  select(description, gene_name, everything()) %>% head(20)
```

## Univariate DR

Run in script 12, with results loaded ex post facto.

```{r, eval=F}
if(file.exists(file.path(resDir, "12_allgenes_univ_dr.Rds")) == F | overwrite == T){
  print("Starting univariate analysis for distant recurrence")
  start <- Sys.time()
  univ_gene_formulas <- sapply(
    colnames(coxdata)[21:ncol(coxdata)],
    function(x) as.formula(
      paste(
        'Surv(time=months_to_drs, event=distant_recurrence)~',
        x)))

  univ_gene_models <- lapply(univ_gene_formulas, function(x){coxph(x, data = coxdata)})
  end <- Sys.time()
  print(end-start)

  saveRDS(univ_gene_models, file=file.path(resDir, "12_allgenes_univ_dr.Rds"))
}
```

>Time difference of 30.5964 mins
Warning messages:
1: In fitter(X, Y, strats, offset, init, control, weights = weights,  :
  Loglik converged before variable  1 ; coefficient may be infinite. 
2: In fitter(X, Y, strats, offset, init, control, weights = weights,  :
  Loglik converged before variable  1 ; coefficient may be infinite. 

```{r}
univ_gene_dr = readRDS(file=file.path(resDir, "12_allgenes_univ_dr.Rds"))
```

With ~30K genes, we'll need to apply multiple testing correction.

```{r}
start <- Sys.time()
res_allgenes_univ_dr <- extract_genewise_cox_results(cox_models = univ_gene_dr,
                                                      type = "univariate") %>%
  mutate(fdr = p.adjust(p.value, method = "fdr")) %>%
  select(gene_name, fdr, beta, `HR (95% CI for HR)`, everything())

end <- Sys.time()

print(end-start)
```

Top 30 most significant results.

```{r}
head(res_allgenes_univ_surv, 30)
```


### Poor prognosis

Higher gene expression = worse prognosis

Here there are far, far more genes significant when using an fdr threshold of 0.2 than with the multivariate distant recurrence model.

```{r}
print(paste("Number of genes negatively associated with metastasis, fdr < 0.2:",
      nrow(res_allgenes_univ_dr %>% filter(beta > 0 & fdr < 0.2))))

#res_allgenes_univ_dr %>% filter(beta > 0 & fdr < 0.2) %>%
#  select(description, gene_name, everything())
```

Looking at those genes with an fdr < 0.05:

```{r}
print(paste("Number of genes negatively associated with distant recurrence, fdr < 0.05:",
      nrow(res_allgenes_univ_dr %>% filter(beta > 0 & fdr < 0.05))))

res_allgenes_univ_dr %>% filter(beta > 0 & fdr < 0.05) %>%
  select(description, gene_name, everything())
```


### Good prognosis

Higher gene expression = better prognosis

Also here there are far more fdr significant genes than in the multivariate model.

```{r}
print(paste("Number of genes positively associated with metastasis, fdr < 0.05:",
      nrow(res_allgenes_univ_dr %>% filter(beta < 0 & fdr < 0.05))))
res_allgenes_univ_dr %>% filter(beta < 0 & fdr < 0.05) %>%
  select(description, gene_name, everything())
```



## Write results: all genes

Combine overall survival and metastasis Cox models for all genes.

```{r, warning=F}
meta_allgenes <- tibble(
  Name = c("univ_cox_surv",
           "univ_cox_dr",
           "multi_cox_surv",
           "multi_cox_dr",
           "metadata",
           "input_diffex"),
  Type = c(rep("Univariate",2),
            rep("Multivariate",2),
           "sample metadata",
           "log2 cpm normalized gene expression matrix"),
  Formula = c("Surv(time=months_overall_survival,event=overall_survival)~gene",
              "Surv(time=months_to_drs,event=distant_recurrence)~gene",
              "Surv(time=months_overall_survival,event=overall_survival)~age_at_diagnosis+year_of_diagnosis+stage+grade+PAM50+gene",
              "Surv(time=months_to_drs,event=distant_recurrence)~age_at_diagnosis+year_of_diagnosis+stage+grade+PAM50+gene",
              NA, NA),
  Package = c(rep("survival/survminer",4), NA, NA),
  Test = c("Cox survival", "Cox metastasis", "Cox survival", "Cox metastasis", NA, "Log2/Cpm"))


openxlsx::write.xlsx(list(description = meta_allgenes,
                          univ_cox_surv = res_allgenes_univ_surv,
                          univ_cox_dr = res_allgenes_univ_dr,
                          multi_cox_surv = res_allgenes_multivar_surv,
                          multi_cox_dr = res_allgenes_multivar_dr,
                          metadata = as.data.frame(colData(dds)),
                          input_norm_geneEx = rownames_to_column(as.data.frame(t(mat)), "ensembl_gene_id")),
                     file = here("results", "survival", "12_cox_allgenes.xlsx"))
```

# Covariate selection with Cox Elastic Net

A pentalized cox model to determine which groups of covariates are most predictive of survival.

We'll want two versions: One matrix with just the gene expression, and one with gene expression plus clinical covariates.

```{r}
enet.gene <- coxdata[,21:ncol(coxdata)] #Gene names start at position 21
rownames(enet.gene) <- coxdata$sample_name
enet.gene <- as.matrix(enet.gene)


enet.clin <- coxdata[,c(which(colnames(coxdata) %in% covariates), 21:ncol(coxdata))]
rownames(enet.clin) <- coxdata$sample_name
enet.clin <- as.matrix(enet.clin)
```


For family="cox", y should be a two-column matrix with columns named 'time' and 'status'. The latter is a binary variable, with '1' indicating death, and '0' indicating right censored.  

Overall survival

```{r}
os = data.frame(time = coxdata$months_overall_survival, event = coxdata$overall_survival)
rownames(os) = coxdata$sample_name

#os = as.matrix(os)
os = Surv(os$time, os$event)
head(os)
```

Metastasis
When looking at drs, time point 0 (metastatic at diagnosis) is not allowed

```{r}
drs = data.frame(time = coxdata$months_to_drs, event = coxdata$distant_recurrence)
rownames(drs) = coxdata$sample_name
drs = drs[!rownames(drs) %in% met_at_diag,]
#Some samples have months_to_drs = 0

drs = drs[drs$time!=0,]
#drs = as.matrix(drs)
drs = Surv(drs$time, drs$event)
head(drs)

enet.gene.drs = enet.gene[!(rownames(enet.gene) %in% met_at_diag),]
enet.clin.drs = enet.clin[!(rownames(enet.clin) %in% met_at_diag),]
```

```{r}
nested.cox <- function(x,y,nfolds=10,nfolds_inner=10,
                       s="lambda.min",
                       alpha=0.5){
  #Based on nested.cv from the TANDEM package

  n = length(y)
  foldid = ceiling(sample(1:n)/n * nfolds)
  
  fitted_relative_risk = rep(NA, length(y))
  #y_hat = rep(NA, length(y))
  
  features = list()
  fitplots = list()
  results = list()
  
  for (i in 1:nfolds) {
      ind = foldid == i
      x_train = x[!ind, ]
      y_train = y[!ind]
      x_test = x[ind, ]
      n_i = length(y_train)
      foldid_i = ceiling(sample(1:n_i)/n_i * nfolds_inner)
      fit = glmnet::cv.glmnet(x_train, y_train, family = "cox", alpha = alpha,
                              foldid = foldid_i)
      fitplots[[length(fitplots) + 1]] = fit
      features[[length(features) + 1]] = coef(fit, s=s)[,1] %>% enframe() %>% filter(value!=0 & name != "(Intercept)")
      fitted_relative_risk[ind] = as.vector(glmnet::predict.cv.glmnet(fit, 
              newx = x_test, s = s, alpha=alpha, type="response"))
        
      print(i) 
      }

  results$features <- features
  results$fitplots <- fitplots
  
  return(results)
}
```


## Overall survival

Run in script 12, results loaded here.

### OS genes as features

```{r, eval=F}
set.seed(123)
start <- Sys.time()
glm.os <- nested.cox(x = enet.gene, y = os, s = "lambda.min", alpha = 0.5)
end <- Sys.time()
print(end-start)
saveRDS(glm.os, file.path(resDir,"12_glm_os_gene.Rds"))
```

```{r}
glm.os <- readRDS(file.path(resDir,"12_glm_os_gene.Rds"))
```


#### Model plots

Plots of 10 cross-validation runs. Performance is fairly consitent below 100 transcripts, with little performance gained from 1 to ~60 features selected.

```{r, fig.width=8, fig.height=10}
par(mar=c(4,4,2,2))
par(mfrow=c(5,2))
lapply(glm.os$fitplots, plot)
```

Zoom in on a sample plot with less than 100 features selected. Requires rerunning glmnet, so we'll do it only once.

```{r}
glm.os.zoom = cv.glmnet(x = enet.gene, y = os, family = "cox", alpha = 0.5,df=100)
plot(glm.os.zoom)
```

#### Features

Number of features selected over 10 xval loops

```{r}
sapply(glm.os$features, nrow) %>% sort()
```

Recurring features in 10 xval loops

```{r}
recurring_features <- function(glm_results, anno_df = gx_annot){
  #Takes a list of fit objects where the coefficients are ensembl gene ids
  #Anno_df should be an annotation data frame that contains an ensembl_gene_id column
  
  feat = bind_rows(glm_results$features) %>%
    group_by(name) %>%
    summarise(n=n(), mean_beta = mean(value), sd_beta = sd(value)) %>%
    arrange(desc(n)) %>%
    left_join(.,gx_annot, by=c("name"="ensembl_gene_id")) 
  return(feat)
}
```


```{r}
glm.os.features = recurring_features(glm.os)
glm.os.features %>% head(30)
```

### OS genes, including clinical covariates

```{r, eval=F}
if(file.exists(file.path(resDir, "12_glm_os_clin.Rds")) == F | overwrite == T){
  print("Elastic Cox for overall survival, including clinical covariates...")
  start <- Sys.time()
  glm.os.clin <- nested.cox(x = enet.clin, y = os, s = "lambda.min", alpha = 0.5)
  end <- Sys.time()
  print(end-start)
  saveRDS(glm.os.clin, file.path(resDir,"12_glm_os_clin.Rds"))
}
```

```{r}
glm.os.clin <- readRDS(file.path(resDir,"12_glm_os_clin.Rds"))
```


#### Model plots

Plots of 10 cross-validation runs. Result is (unsurprisingly) similar to the gene-only overall survival model.

```{r, fig.width=8, fig.height=10}
par(mar=c(4,4,2,2))
par(mfrow=c(5,2))
lapply(glm.os.clin$fitplots, plot)
```

#### Features

Number of features selected over 10 xval loops

```{r}
sapply(glm.os.clin$features, nrow) %>% sort()
```

Recurring features in 10 xval loops

```{r}
glm.os.clin.features = recurring_features(glm.os.clin)

glm.os.clin.features %>% head(30)
```

Very similar to the model without clinical features. Surprising however is that stage is only selected as a feature in 2 out of 10 models, and the beta is relatively weak.

```{r}
glm.os.clin.features %>% 
  filter(!str_detect(name, "ENSG"))
```

## DRS/metastasis

Run in script 12, results loaded here.

### DRS genes as features

```{r, eval=F}
if(file.exists(file.path(resDir, "12_glm_drs_gene.Rds")) == F | overwrite == T){
  print("Elastic Cox for distant recurrence (metastasis), genes only...")
  start <- Sys.time()
  glm.drs <- nested.cox(x = enet.gene.drs, y = drs, s = "lambda.min", alpha = 0.5)
  end <- Sys.time()
  print(end-start)
  saveRDS(glm.drs, file.path(resDir,"12_glm_drs_gene.Rds"))
}
```

```{r}
glm.drs <- readRDS(file.path(resDir,"12_glm_drs_gene.Rds"))
```


#### Model plots

Plots of 10 cross-validation runs. Performance is fairly consitent below 100 transcripts, with little performance gained from 1 to ~60 features selected.

```{r, fig.width=8, fig.height=10}
par(mar=c(4,4,2,2))
par(mfrow=c(5,2))
lapply(glm.drs$fitplots, plot)
```


#### Features

Number of features selected over 10 xval loops

```{r}
sapply(glm.drs$features, nrow) %>% sort()
```

Recurring features in 10 xval loops. Is a bit more consistent than OS.

```{r}
glm.drs.features = recurring_features(glm.drs)
glm.drs.features %>% head(30)
```

### DRS genes, including clinical covariates

```{r, eval=F}
if(file.exists(file.path(resDir, "12_glm_drs_clin.Rds")) == F | overwrite == T){
  print("Elastic Cox for distant recurrence, including clinical covariates...")
  start <- Sys.time()
  glm.os.clin <- nested.cox(x = enet.clin, y = os, s = "lambda.min", alpha = 0.5)
  end <- Sys.time()
  print(end-start)
  saveRDS(glm.drs.clin, file.path(resDir,"12_glm_drs_clin.Rds"))
}
```

```{r}
glm.drs.clin <- readRDS(file.path(resDir,"12_glm_drs_clin.Rds"))
```


#### Model plots

Plots of 10 cross-validation runs. Result is (unsurprisingly) similar to the gene-only overall survival model.

```{r, fig.width=8, fig.height=10}
par(mar=c(4,4,2,2))
par(mfrow=c(5,2))
lapply(glm.os.clin$fitplots, plot)
```

#### Features

Number of features selected over 10 xval loops

```{r}
sapply(glm.drs.clin$features, nrow) %>% sort()
```

Recurring features in 10 xval loops

```{r}
glm.drs.clin.features = recurring_features(glm.drs.clin)

glm.drs.clin.features %>% head(30)
```

Very similar to the model without clinical features. Unlike overall survival, stage is much more important.

```{r}
glm.os.clin.features %>% 
  filter(!str_detect(name, "ENSG"))
```

# To be discussed: Predictions

Paraphrased from [this post](https://stats.stackexchange.com/questions/388770/cox-model-with-lasso-using-one-dataset-and-predicting-in-a-different-dataset) and confirmed by Misha:

With cox models, type = "link" gives the linear predictor. (Recap: The linear predictor is a linear sum of the effects of one or more explanatory variables). The right-hand side of the equation is called the linear structure. Type = response is essentially the exponential of the linear predictor, giving a relative risk of survival outcome. It's relative between samples, so if you want to get survival probability, a baseline measure must be calculated (comparable to intercept).

However, the Cox model itself cannot give you the S0, you need another method to estimate the S0, for example, fitting your covariate with beta into a coxph model with initial covariates and then estimate baseline with basehaz. See also: [Frailtypack](https://cran.r-project.org/web/packages/frailtypack/index.html) (R package)

```{r}
relrisk.df = sapply(glm.os$fitplots, function(x) glmnet::predict.cv.glmnet(x, 
                newx = enet.gene, s = "lambda.min", alpha=0.5, type="response")) %>%
  set_colnames(., paste("fitted.rel.risk",1:10, sep="_")) %>% as.data.frame() %>%
  set_rownames(rownames(enet.gene))

head(relrisk.df)
```

In intercept-only (zero feature) models, the relative risk is reported as 1 across all samples

```{r}
relrisk.df[,which(sapply(glm.os$features, nrow)==0)] %>% head()

relrisk.df <- relrisk.df[,-c(which(sapply(glm.os$features, nrow)==0))]
```

```{r, eval=F}
#Heatmap contains too many outliers to be informative
pheatmap(relrisk.df, annotation_row = sd[,"study_group", drop=F], show_rownames = F, scale="column")
```

Because the risk is relative between samples, we take the Z score centered on column

```{r}
z.relrisk = as.data.frame(scale(relrisk.df))

z.relrisk = rownames_to_column(z.relrisk, "sample_name") %>%
  gather(key = model, value="rel.risk", -sample_name)

head(z.relrisk)
```


## Plotting rel risk by survival

```{r}
relplot.df = coxdata %>% select(months_overall_survival, overall_survival, study_group) %>%
  rownames_to_column("sample_name") %>%
  mutate(death = if_else(overall_survival==1, T, F)) %>%
  left_join(., z.relrisk, by = "sample_name")

relplot.df %>% head(10)
```

To do: Split the training and test samples properly

```{r, fig.width=10}
relplot.df %>%
  ggerrorplot(.,x = "months_overall_survival", y = "rel.risk", color="death", shape="study_group") +
  ggtitle("Relationship between relative risk and survival") +
  rotate_x_text(90)

#ggpar(erplot,xticks.by = 20) #DOesn't work

#gpar(erplot, font.x = 4) #Also doesn't work
```

```{r}
?ggpar
```


```{r}
relplot.df %>%
  ggplot(aes(x = months_overall_survival, y = rel.risk, color=death, shape=study_group)) +
  geom_point() +
  ggtitle("Relationship between relative risk and survival")
```



```{r, eval=F}

#Coloring by study group is less informative
relplot.df %>%
  ggplot(aes(x = months_overall_survival, y = rel.risk, shape=death, color=study_group)) +
  geom_point() +
  ggtitle("Relationship between relative risk and survival")
```





```{r}
set.seed(123)

glm.os.clin = cv.glmnet(x = enet.clin, y = os, family = "cox", alpha = 0.5)
plot(glm.os.clin)
```



TODO
We rank the features according to an importance metric, which we define as the coefficient scaled by variance(yhat).

```{r}
coef(glm.os.clin, s="lambda.min")[,1] %>% enframe() %>%
  filter(value != 0 & name != "(Intercept)")
```



```{r}
#enet.gene[1:10,1:10]
glm.drs = cv.glmnet(x = enet.gene.drs, y = drs, family = "cox", alpha = 0.5)
glm.drs.clin = cv.glmnet(x = enet.clin.drs, y = drs, family = "cox", alpha = 0.5)
```

```{r}
plot(glm.drs)
```

```{r}
plot(glm.drs.clin)
```

```{r}
coef(glm.drs.clin, s="lambda.min")[,1] %>% enframe() %>%
  filter(value != 0 & name != "(Intercept)")
```





# Select genes of interest

Load the LRT results for plotting.

```{r}
#excel_sheets(here("results", "diffex", "06_LRT.xlsx"))

lrt = readxl::read_excel(here("results", "diffex", "06_LRT.xlsx"), sheet="all_genes")
head(lrt)
```

Modify beehive function for Cox results

```{r}
plot_cox_beehive <- function(dds, res_df, cox_df){
  p <- plot_gene_beehive(dds, res_df)
  p <- p + ggtitle()
  #TODO Finish me
}
```


## [ALOX12B](https://www.genecards.org/cgi-bin/carddisp.pl?gene=ALOX12B)

>Non-heme iron-containing dioxygenase that catalyzes the stereo-specific peroxidation of free and esterified polyunsaturated fatty acids generating a spectrum of bioactive lipid mediators. Mainly converts arachidonic acid to (12R)-hydroperoxyeicosatetraenoic acid/(12R)-HPETE and minor stereoisomers. In the skin, acts upstream of ALOXE3 on the lineolate moiety of esterified omega-hydroxyacyl-sphingosine (EOS) ceramides to produce an epoxy-ketone derivative, a crucial step in the conjugation of omega-hydroxyceramide to membrane proteins. Therefore plays a crucial role in the synthesis of corneocytes lipid envelope and the establishment of the skin barrier to water loss. May also play a role in the regulation of the expression of airway mucins.

Fix to plot p value from cox instead of diffex (TODO)

```{r}
plot_gene_beehive(dds, lrt[lrt$ensembl_gene_id=="ENSG00000179477",])
```

## Unsorted beehives

TODO: Sort me (and fix titles)

### Multivar Survival

#### Negative

```{r}
for (i in res_allgenes_multivar_surv %>% filter(beta > 0 & fdr < 0.2) %>% pull(ensembl_gene_id)){
  print(plot_gene_beehive(dds, lrt[lrt$ensembl_gene_id==i,]))
}
  
```

#### Positive

```{r}
for (i in res_allgenes_multivar_surv %>% filter(beta < 0 & fdr < 0.2) %>% pull(ensembl_gene_id)){
  print(plot_gene_beehive(dds, lrt[lrt$ensembl_gene_id==i,]))
}
  
```

### Multivar metastasis

#### Negative

Too many to easily plot. Top 10 only.

```{r, eval=F}
temp = res_allgenes_multivar_dr %>% filter(beta > 0 & fdr < 0.2) %>% pull(ensembl_gene_id)
for (i in 1:10){
  print(plot_gene_beehive(dds, lrt[lrt$ensembl_gene_id==temp[i],]))
}
```

#### Positive

Top 10 only

```{r}
temp = res_allgenes_multivar_dr %>% filter(beta < 0 & fdr < 0.2) %>% pull(ensembl_gene_id)
for (i in 1:10){
  #print(temp[i])
  print(plot_gene_beehive(dds, lrt[lrt$ensembl_gene_id==temp[i],]))
}
```


### Univar metastasis

#### Negative

Here there are far, far more genes significant when using an fdr threshold of 0.2 than with the multivariate distant recurrence model.


Looking at those genes with an fdr < 0.05:

```{r}
print(paste("Number of genes negatively associated with distant recurrence, fdr < 0.05:",
      nrow(res_allgenes_univ_dr %>% filter(beta > 0 & fdr < 0.05))))

for (i in res_allgenes_univ_dr %>% filter(beta < 0 & fdr < 0.05) %>% pull(ensembl_gene_id)){
  print(plot_gene_beehive(dds, lrt[lrt$ensembl_gene_id==i,]))
}
```


#### Positive

Also here there are far more fdr significant genes than in the multivariate model.

```{r}
print(paste("Number of genes positively associated with metastasis, fdr < 0.05:",
      nrow(res_allgenes_univ_dr %>% filter(beta < 0 & fdr < 0.05))))
temp = res_allgenes_univ_dr %>% filter(beta < 0 & fdr < 0.05) %>% pull(ensembl_gene_id)
for (i in 1:10){
  print(plot_gene_beehive(dds, lrt[lrt$ensembl_gene_id==temp[i],]))
}
``` 

## Save data

Remove extremely large objects first (over 1GB memory)

```{r}
ls(pattern = "multivar_gene")
rm("multivar_gene_dr")
rm("multivar_gene_surv")

ls(pattern = "univ_gene")
rm("univ_gene_dr")
rm("univ_gene_models")
rm("univ_gene_surv")
```


```{r}
save.image(here("reports", "12_survival.RData"))
```

