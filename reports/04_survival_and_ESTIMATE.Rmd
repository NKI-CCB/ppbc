---
title: "Survival and ESTIMATE"
date: "`r Sys.Date()`"
author: "Kat Moore"
output: 
  html_document:
    toc: yes
    toc_float: yes
    toc_depth: 4
    highlight: tango
    df_print: paged
---

```{r, include=F}
rm(list = ls())
```

```{r, include=F}
library(DESeq2)
library(here)
library(estimate)
library(tidyverse)
library(survival)
library(survminer)
library(ggthemes)
library(RColorBrewer)
library(ggpubr)
```

```{r Default ggplot themes, include=F}
options(ggplot2.continuous.colour = "viridis")
options(ggplot2.continuous.fill = "viridis")
scale_colour_discrete <- scale_color_colorblind
#scale_colour_discrete <- scale_colour_viridis_d

#For fill
#viridis_qualitative_pal7 <- c("#440154FF", "#FDE725FF", "#443A83FF", 
#                              "#8FD744FF", "#31688EFF",  "#35B779FF", 
#                              "#21908CFF")

scale_fill_discrete <- function(...) {
  #scale_fill_manual(..., values = viridis_pal()(7)) #Wrong order
  #scale_fill_manual(..., values = viridis_qualitative_pal7)
  scale_fill_manual(..., values = colorblind_pal()(8))
}

theme_set(theme_minimal())
```

In this notebook, we use ESTIMATE to calculate immune/stromal scores and tumor purity for the PPBC dataset.
Several survival analyses are also performed.

# Load data

```{r}
dds <- readRDS(here("data/Rds/03_dds_PAM50.Rds"))

tx_annot <- read_tsv(here("data/metadata/01_tx_annot.tsv"))

color_palettes = readRDS(here("data/Rds/color_palettes.Rds"))
```

We only need the gene id and hgnc symbol for this script.

```{r}
tx_annot = tx_annot %>%
  select(gene_id, hgnc_symbol) %>%
  distinct()
```

# Conversion to FPKM with HUGO symbols

Esimate requires transcript length normalization and gene names instead of ensembl ids.

Debatable: whether to use robust = T or F when calculating fpkm for the purposes of determining tumor purity with Estimate. 
When True, estimateSizeFactors is called to more accurately normalize by library size. 
Use the robust = F option to disable the median ratio normalization and just get classical fpkm via colSums.

Since we prefer a more robust correction for library size, choose robust = T.

```{r}
fpkm <- DESeq2::fpkm(dds, robust = T)
```

Add the HUGO symbols

```{r}
fpkm <- fpkm %>%
  as.data.frame() %>%
  rownames_to_column("gene_id") %>%
  right_join(select(tx_annot, gene_id, hgnc_symbol),
             .,
             by = "gene_id")
```

Make sure we don't have any NAs in the HGNC field.

```{r}
print(paste("Removing",
            sum(is.na(fpkm$hgnc_symbol)),
            "genes without HUGO ids from the fpkm matrix."))

fpkm <- fpkm %>% filter(!is.na(hgnc_symbol))
```

```{r}
print(paste(nrow(fpkm), "genes remaining in the fpkm matrix."))
```

Drop the ensembl id column.

```{r}
fpkm <- fpkm %>% select(-gene_id)
```

# De-duplicate gene symbols

When dealing with duplicated gene names, take the mean fpkm.

```{r}
summarize_expression_duplicate_ids <- function(mat, id_column, f=colMeans,
                                               final_gene_symbol_colname="GeneSymbol"){
  require(dplyr)
  
  print(paste("Starting with gene expression matrix containing", nrow(mat), "rows."))
  
  #Easiest way to write functions with dplyr is to standardize the column name
  
  if(id_column != "symbol"){
    colnames(mat)[colnames(mat)==id_column] <- "symbol"
  }
  
  #Make frequency table
  id_table <- as.data.frame(table(mat$symbol))
  
  #Identify duplicate genes
  dups <- id_table$Var1[id_table$Freq > 1]
  stopifnot(length(dups) == length(unique(dups)))
  print(paste("Number of genes with duplicate names:", length(dups)))
  
  #Set aside rows with unique gene names
  nodup_df <- mat[!mat$symbol %in% dups,]
  
  #Set aside rows with duplicate ids
  dup_df <- mat[mat$symbol %in% dups,]
  stopifnot(nrow(nodup_df) + nrow(dup_df) == nrow(mat))
  
  #Sort by recurring id
  dup_df <- dup_df[order(dup_df$symbol),]
  
  print(paste("Number of rows with duplicate gene ids:", nrow(dup_df)))
  
  #Mean expression fpkm of genes with the same symbol
  mean_exps <- matrix(ncol = ncol(dup_df)-1, nrow=0) #Empty matrix, -1 gene symbol column

  for (i in 1:length(unique(dup_df$symbol))){
    #Subset rows with same symbol, discard symbol column, then apply aggregate function
    exp <- f(as.matrix(dup_df[dup_df$symbol==unique(dup_df$symbol)[i], -1])) 
    mean_exps <- rbind(mean_exps, exp)
  }
  stopifnot(nrow(mean_exps) == length(unique(dup_df$symbol)))
  
  rownames(mean_exps) <- unique(dup_df$symbol)
  mean_exps <- as.data.frame(mean_exps) %>% rownames_to_column("symbol")
  
  dedupped_df <- rbind(mean_exps, nodup_df)
  dedupped_df <- dedupped_df[order(dedupped_df$symbol),]
  
  stopifnot(length(unique(dedupped_df$symbol))==length(dedupped_df$symbol)) #All symbols should not be unique
  stopifnot(nrow(mat) - #starting number
            nrow(dup_df) + #rows with duplicate genes...
            length(dups) == #...which condense down into this many unique genes...
            nrow(dedupped_df)) #...should equal the number of rows in the final matrix

  print(paste("Number of genes after applying", substitute(f),  "to duplicate ids:", nrow(dedupped_df)))
  
  #For estimate, the column with identifiers HAS to be called GeneSymbol or EntrezGeneID
  colnames(dedupped_df)[colnames(dedupped_df)=="symbol"] <- final_gene_symbol_colname
  
  return(dedupped_df)
}
```

```{r}
clean_fpkm <- summarize_expression_duplicate_ids(fpkm, "hgnc_symbol")
```

```{r}
head(clean_fpkm)
```

The input for ESTIMATE can supposedly be a dataframe, but the function throws an error unless provided with a file..

```{r}
write.table(clean_fpkm, sep = "\t", file = here("data","RNA-seq","hugo_fpkm.txt"), col.names = T, row.names =F, quote=F)
```

# ESTIMATE

Estimate really only has two functions of interest for us. 
The first is filterCommonGenes, which unifies genes symbols provided versus the 10,412 used for determining tumor purity.

It requires writing a file instead of returning an object within the R environment. 

```{r}
dir.create(here("results","ESTIMATE"), showWarnings = F)

filterCommonGenes(input.f=here("data","RNA-seq","hugo_fpkm.txt"),
                  output.f = here("results/ESTIMATE/filterCommonGenes.gct"), id="GeneSymbol")
```

The next function computes stromal, immune, and ESTIMATE scores per sample using gene expression data. It also insists on writing files.

```{r}
estimateScore(input.ds = here("results","ESTIMATE","filterCommonGenes.gct"),
              output.ds = here("results","ESTIMATE","results_estimate_score.gct"),
              platform="illumina")
```

```{r}
scores <- read.delim(here("results","ESTIMATE","results_estimate_score.gct"), skip=2, sep="\t")
scores[,1:6]
```

## Purity score calculation

Note: Only validated for microarray data:
Tumour purity=cos (0.6049872018+0.0001467884 × ESTIMATE score)
[Source](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3826632/)

```{r}
purity_score <- scores %>%
  dplyr::select(-Description) %>%
  rename(score=NAME) %>%
  gather(key="sample_name", -score, value=value) %>%
  mutate(sample_name=str_replace_all(sample_name, "\\.","-")) %>%
  spread(key=score,value=value) %>%
  mutate(tumor_purity = cos(0.6049872018+0.0001467884 * ESTIMATEScore))
```

# Stromal and Immune Scores

## General

Bar plot

```{r}
scores %>% dplyr::select(-Description) %>%
  gather(key = "sample_name", -NAME, value="Score") %>%
  left_join(., as.data.frame(colData(dds)), by="sample_name") %>%
  arrange(PPBC) %>%
  ggplot(aes(x=factor(sample_name, levels = unique(sample_name)),y=Score, fill=PPBC)) +
  geom_bar(stat="identity") +
  facet_wrap(~NAME, ncol=1) +
  theme(axis.text.x=element_blank()) +
  xlab("Samples") +
  scale_fill_manual(values = color_palettes$ppbc_colors)
``` 

Box plots

```{r}
scores %>% dplyr::select(-Description) %>%
  gather(key = "sample_name", -NAME, value="Score") %>%
  left_join(., as.data.frame(colData(dds)), by="sample_name") %>%
  filter(NAME != "ESTIMATEScore") %>%
  ggplot(aes(x=PPBC,y=Score, color=PPBC)) +
  geom_boxplot(alpha = 0) +
  ggbeeswarm::geom_quasirandom(method="smile") +
  facet_wrap(~NAME, ncol=2) +
  theme(legend.position = "none") +
  scale_color_manual(values = color_palettes$ppbc_colors)
  #xlab("Samples")
```

## Immune scores

```{r}
comps <- list( c("nulliparous", "involuting"),
               c("lactating", "involuting"),
               c("pregnant", "involuting") )


immune_df = scores %>% dplyr::select(-Description) %>%
  gather(key = "sample_name", -NAME, value="Score") %>%
  left_join(., as.data.frame(colData(dds)), by="sample_name") %>%
  filter(NAME == "ImmuneScore") 

immune_df %>%
  ggboxplot(x="PPBC", y="Score", add="dotplot", 
          color = "PPBC", notch = T) +
  theme(legend.position = "none") +
  ggtitle("Immune Score by study group") + 
  stat_compare_means(comparisons = comps)+ 
  stat_compare_means(label.y = 3500) +
  scale_color_manual(values = color_palettes$ppbc_colors) +
  scale_fill_manual(values = color_palettes$ppbc_colors)
```

```{r}
comps <- list( c("Basal", "LumA"),
               c("Basal", "LumB"),
               c("Basal", "Her2"),
               c("Basal", "Normal"))

immune_df %>%
  ggboxplot(x="PAM50", y="Score", add="dotplot", 
          color = "PAM50", notch = F,
          order = c("LumA", "LumB", "Basal", "Her2", "Normal")) +
  theme(legend.position = "none") +
  ggtitle("Immune Score by PAM50") + 
  stat_compare_means(comparisons = comps)+ 
  stat_compare_means(label.y = 3500) +
  scale_color_manual(values = color_palettes$pam_colors) +
  scale_fill_manual(values = color_palettes$pam_colors)
```

## Stromal Scores

```{r}
comps <- list( c("nulliparous", "involuting"),
               c("lactating", "involuting"),
               c("pregnant", "involuting") )


stromal_df <- scores %>% dplyr::select(-Description) %>%
  gather(key = "sample_name", -NAME, value="Score") %>%
  left_join(., as.data.frame(colData(dds)), by="sample_name") %>%
  filter(NAME == "StromalScore") 

stromal_df %>%
  ggboxplot(x="PPBC", y="Score", add="dotplot", 
          color = "PPBC", notch = T) +
  theme(legend.position = "none") +
  ggtitle("Stromal Score by study group") + 
  stat_compare_means(comparisons = comps)+ 
  stat_compare_means(label.y = 2500) +
  scale_color_manual(values = color_palettes$ppbc_colors) +
  scale_fill_manual(values = color_palettes$ppbc_colors)
```

```{r}
comps <- list( c("Basal", "LumA"),
               c("Basal", "LumB"),
               c("Basal", "Her2"),
               c("Basal", "Normal"))

stromal_df %>%
  ggboxplot(x="PAM50", y="Score", add="dotplot", 
          color = "PAM50", notch = F,
          order = c("LumA", "LumB", "Basal", "Her2", "Normal")) +
  theme(legend.position = "none") +
  ggtitle("Stromal Score by PAM50") + 
  stat_compare_means(comparisons = comps)+ 
  stat_compare_means(label.y = 2500)+
  scale_color_manual(values = color_palettes$pam_colors) +
  scale_fill_manual(values = color_palettes$pam_colors)
```

# Survival setup

Add immune, stromal and tumor purity to metadata

```{r}
stopifnot(all(colData(dds)$sample_name == purity_score$sample_name))
dds$immune_score = purity_score$ImmuneScore
dds$stromal_score = purity_score$StromalScore
dds$tumor_purity = purity_score$tumor_purity
```

## Prepare metadata

Covariates: grade, stage, molecular subtype, age at diagnosis, year of diagnosis, therapy type(s)

We will try to keep the columns of the metadata as consistent as possible between versions.

```{r}
sd = as.data.frame(colData(dds))
sd = sd %>%
  select(sample_name, patient_ref, reason_death, 
         study_group, PPBC, PAM50,
         grade = grade_integer, stage = stage_short_integer,
         months_of_followup, year_of_diagnosis = year_diagnosis,
         age_at_diagnosis = age_diagnosis, metastasis_at_diagnosis,
         overall_survival, months_overall_survival,
         distant_recurrence, months_to_drs, surgery,
         radiotherapy = RT, hormonetherapy = HT,
         chemotherapy = CT, herceptin = HERC
         )

sd %>% head()
```

How many samples lack complete info?

In total 15 such samples are excluded.

```{r}
samples_missing_info <- sd[rowSums(is.na(sd))> 0,]

samples_missing_info
```

```{r}
write_csv(samples_missing_info,
          here("data/metadata/04_samples_with_missing_survival_data.csv"))
```


## Excluded samples

Exclude samples for which there has been less than 20 months of follow up, unless the reason for the lack of follow up is that the patient passed away due to disease (and not an accident or suicide).

In this version, non-BC deaths have been already filtered out

```{r}
unique(sd$reason_death)
```

follow_up > 20 | death == 1

```{r, collapse=T}
print(paste("Started with", nrow(sd), "samples"))

print(paste("Samples with missing values in survival data:",
            length(samples_missing_info)))
excluded = sd %>% filter(sample_name %in% samples_missing_info$sample_name) %>%
  mutate(reason = "missing survival data")

print(paste("Samples excluded due to patient death unrelated to disease:",
            nrow(sd %>% filter(!reason_death %in% c("alive", "BC")))))

excluded = bind_rows(excluded,
                     mutate(filter(sd, !reason_death %in% c("alive", "BC")),
                            reason = "unrelated death")
                     )

print(paste("Samples excluded due to insufficient follow up:",
      nrow(sd %>% filter(months_of_followup < 20 & reason_death == "BC"))))

excluded = bind_rows(excluded,
                     mutate(filter(sd, months_of_followup < 20 & reason_death == "BC"),
                            reason = "insufficient followup"))

metadata = sd %>% filter(!sample_name %in% samples_missing_info$sample_name) %>%
  filter(reason_death %in% c("alive", "BC")) %>%
  filter(months_of_followup >= 20 | reason_death == "BC")

print(paste(nrow(metadata), "samples remaining post filtering"))

stopifnot(all(rowSums(is.na(metadata)) == 0))
```

Save metadata

```{r}
write_csv(metadata,
          path = here("data/metadata/04_survival_metadata.csv"))
```

Overview excluded samples:

```{r}
excluded = select(excluded, reason, everything()) %>% arrange(sample_name)

table(excluded$sample_name, excluded$reason)

openxlsx::write.xlsx(list(overview = table(excluded$sample_name, excluded$reason),
                          metadata_excluded_samples = excluded),
                          here("data/metadata/04_samples_excluded_survival.xlsx"))
```

We will not be using genes as features in this notebook: those analyses will come later.
The metadata as prepared can be used as input for survival analyses.

```{r}
coxdata = metadata
saveRDS(coxdata, here("data/Rds/04_survdata.Rds"))
```

# Univariate survival curves

Kaplan-meier curves with univariate design (not correcting for clinical covariates).

## Set up tertiles

Define tertiles for immune and stromal scores when plotting.

```{r calculate tertiles}
immune_df$tertile = dplyr::ntile(immune_df$Score, 3)
stromal_df$tertile = dplyr::ntile(stromal_df$Score, 3)

tertile_colors = color_palettes$tertile_colors
names(tertile_colors) = c(1,2,3)

bind_rows(immune_df, stromal_df) %>%
  ggplot(aes(x = NAME, y = Score, color = as.factor(tertile))) +
  geom_jitter() +
  #geom_boxplot(alpha = 0) +
  xlab("") +
  labs(color = "tertile") +
  ggtitle("Distribution of immune and stromal score by tertile") +
  scale_color_manual(values = tertile_colors)

```

```{r add tertitles to metadata}
coxdata = right_join(
  select(immune_df, sample_name, immune_tertile = tertile),
  coxdata, by = "sample_name")
coxdata = right_join(
  select(stromal_df, sample_name, stromal_tertile = tertile),
  coxdata, by = "sample_name")

coxdata = coxdata %>%
  select(sample_name:PAM50, immune_tertile, stromal_tertile, everything())
```

Subset the data down to involution only samples for analyses related to breastfeeding.
Add months_involution_breastfeeding (the number of months since the onset of weaning) and breastfeeding_months (the number of months of breastfeeding before stopping) to the coxdata.
Omit missing values.

```{r}
inv_cox = as.data.frame(colData(dds)) %>%
  filter(study_group == "ppbc_inv") %>%
  select(sample_name, months_involution_breastfeeding, breastfeeding_months) %>%
  na.omit() %>%
  left_join(., coxdata, by = "sample_name") %>%
  na.omit()

print(paste(nrow(inv_cox), "of", nrow(filter(coxdata, study_group == "ppbc_inv")),
            "involution samples with complete metadata have breastfeeding and time since weaning"))
```

```{r}
inv_cox %>%
  select(sample_name, months_involution_breastfeeding, breastfeeding_months) %>%
  gather(key = "type", -sample_name, value = "months") %>%
  ggplot(aes(x = months, fill = type)) +
  geom_density(alpha = 0.5) +
  ggtitle("Distribution of breastfeeding and involution duration")
```
Set up duration categories

```{r}
inv_cox = inv_cox %>%
  mutate(involution = case_when(
    months_involution_breastfeeding < 2 ~ "< 2 months",
    between(months_involution_breastfeeding, 2, 6) ~ "2-6 months",
    between(months_involution_breastfeeding, 7, 12) ~ "7-12 months",
    between(months_involution_breastfeeding, 13, 25) ~ "13-25 months",
  )) %>% mutate(breastfeeding = case_when(
    breastfeeding_months < 1 ~ "< 1 month",
    between(breastfeeding_months, 1, 4) ~ "1-4 months",
    between(breastfeeding_months, 5, 25) ~ "5-25 months"
  )) %>%
  select(sample_name, months_involution_breastfeeding, involution,
         breastfeeding_months, breastfeeding, everything()) %>%
  mutate(involution = factor(involution,
                             levels = c("< 2 months", "2-6 months",
                                        "7-12 months", "13-25 months")),
         breastfeeding = factor(breastfeeding,
                                levels = c("< 1 month", "1-4 months",
                                           "5-25 months")))

inv_cox$involution %>% table()
inv_cox$breastfeeding %>% table()
```

## PPBC

Lactation shows the worst prognosis, followed by involution.

```{r, fig.width = 8}
ppbc_colors = color_palettes$ppbc_colors
names(ppbc_colors) = paste0("PPBC=",names(color_palettes$ppbc_colors))

km_ppbc = survfit(Surv(time=months_overall_survival, event=overall_survival) ~ PPBC, data = coxdata) %>% 
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = paste0("OS: All samples with adequate data (n = ", nrow(coxdata), ")"),
    palette = ppbc_colors,
    #palette = "Dark2",
    #linetype = "strata",
    #conf.int = T,
    pval = T,
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_ppbc$plot #Avoids printing a blank plot
```

```{r, eval=F, include=F}
resDir = here("results", "survival")
dir.create(resDir, showWarnings = F)

pdf(file.path(resDir, "04_km_ppbc.pdf"), width = 8, height = 6)
print(km_ppbc$plot, newpage=F)
dev.off()
```

Survdiff implements the log-rank test, which compares one or more curves vs the null hypothesis that there is no difference in survival between the curves. 
The log-rank statistic is chi-square distributed.

A comparison between all groups is near but not quite significant.

```{r}
survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ PPBC, data = coxdata)
```

Pairwise log-rank tests show that none of the individual pairings are significant.

```{r}
pairwise_survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ PPBC, data = coxdata)
```

## PAM50

PAM50 shows no significant variance by molecular subtype.

```{r}
pam_colors = color_palettes$pam_colors
names(pam_colors) = paste0("PAM50=", names(color_palettes$pam_colors))

km_pam50 = 
survfit(Surv(time=months_overall_survival, event=overall_survival) ~ PAM50, data = coxdata) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = paste0("OS: All samples with adequate data (n = ", nrow(coxdata), ")"),
    pval = T,
    palette = pam_colors,
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_pam50$plot
```

```{r, eval=F, include=F}
pdf(file.path(resDir, "04_km_pam50.pdf"), width = 8, height=6)
print(km_pam50$plot)
dev.off()
```

Log-rank test for PAM50. Basal generally has a worse than expected outcome, consistent with the literature. 
The others are almost exactly matched with expected.

```{r}
survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ PAM50, data = coxdata)
```

Pairwise log-rank tests demonstrate that no pairing is remotely significant.

```{r}
pairwise_survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ PAM50, data = coxdata)
```

## Immune score

A higher immune score is protective.

```{r}
names(tertile_colors) = paste0("tertile=", 1:3)

km_IS = 
survfit(Surv(time=months_overall_survival, event=overall_survival) ~ tertile,
        data = rename(coxdata, tertile = immune_tertile)) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = paste0("Overall survival by immune score (n = ", nrow(coxdata), ")"),
    pval = T,
    palette = tertile_colors,
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_IS$plot
```

```{r, eval=F, include=F}
#pdf(file.path(resDir, "04_km_immune_score.pdf"), width = 8, height=6)
#print(km_IS$plot)
#dev.off()
```

```{r}
survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ immune_tertile, data = coxdata)
```

## Stromal score

The stromal score does not behave linearly.
The second tertile has a poorer outcome than the first or third.

```{r}
km_SS = 
survfit(Surv(time=months_overall_survival, event=overall_survival) ~ tertile,
        data = rename(coxdata, tertile = stromal_tertile)) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = paste0("Overall survival by stromal score (n = ", nrow(coxdata), ")"),
    pval = T,
    palette = tertile_colors,
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_SS$plot
```

```{r, eval=F, include=F}
#pdf(file.path(resDir, "04_km_stromal_score.pdf"), width = 8, height=6)
#print(km_SS$plot)
#dev.off()
```

```{r}
survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ stromal_tertile, data = coxdata)
```

## Time in involution

Distribution of groups:

```{r}
table(inv_cox$involution)
```

```{r, fig.width=8, fig.height=6}
km_time_inv = 
survfit(Surv(time=months_overall_survival, event=overall_survival) ~ involution,
        data = inv_cox) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = paste0("Overall survival by time since weaning (n = ", nrow(inv_cox), ")"),
    pval = T,
    palette = viridis::plasma(length(unique(inv_cox$involution))),
    #palette = ppbc_colors,
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_time_inv$plot

```

Looks like less than 2 months is substantially worse than the rest. Refactor.

```{r}
inv_cox = inv_cox %>%
  mutate(involution = case_when(
    months_involution_breastfeeding < 2 ~ "< 2 months",
    months_involution_breastfeeding >= 2 ~ "> 2 months"
    )) %>% 
  mutate(involution = factor(involution,
                             levels = c("< 2 months", "> 2 months")))

km_time_inv = 
survfit(Surv(time=months_overall_survival, event=overall_survival) ~ involution,
        data = inv_cox) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = paste0("Overall survival by time since weaning (n = ", nrow(inv_cox), ")"),
    pval = T,
    palette = "Dark2",
    #palette = viridis::cividis(length(unique(inv_cox$involution))),
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_time_inv$plot
```

```{r, eval=F}
#Doesn't help
inv_cox = inv_cox %>%
  mutate(involution2 = case_when(
    months_involution_breastfeeding < 3 ~ "< 3 months",
    months_involution_breastfeeding >= 3 ~ ">= 3 months"
    )) %>% 
  mutate(involution2 = factor(involution2,
                             levels = c("< 3 months", ">= 3 months")))

km_time_inv2 = 
survfit(Surv(time=months_overall_survival, event=overall_survival) ~ involution2,
        data = inv_cox) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = paste0("Overall survival by time since weaning (n = ", nrow(inv_cox), ")"),
    pval = T,
    palette = "Dark2",
    #palette = viridis::cividis(length(unique(inv_cox$involution))),
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)
km_time_inv2$plot
```

```{r, eval=F, include=F}
#pdf(file.path(resDir, "04_km_months_inv.pdf"), width = 8, height=6)
#print(km_time_inv$plot)
#dev.off()
```

```{r}
survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ involution, data = inv_cox)
```

## Breastfeeding duration

Distribution of groups:

```{r}
table(inv_cox$breastfeeding)
```

```{r, fig.width=8, fig.height=6}
km_brf = 
survfit(Surv(time=months_overall_survival, event=overall_survival) ~ breastfeeding,
        data = inv_cox) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = paste0("Overall survival by breastfeeding duration (n = ", nrow(inv_cox), ")"),
    pval = T,
    palette = viridis::plasma(length(unique(inv_cox$breastfeeding))),
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_brf$plot

```


```{r, eval=F, include=F}
pdf(file.path(resDir, "04_km_breastfeeding.pdf"), width = 8, height=6)
print(km_brf$plot)
dev.off()
```

```{r}
survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ breastfeeding, data = inv_cox)
```

# Univariate DRS curves

## PPBC

Just like OS, lactation shows the worst prognosis, followed by involution.
The comparison is less significant overall.

```{r, fig.width = 8}
drs_ppbc = survfit(Surv(time=months_to_drs, event=distant_recurrence) ~ PPBC, data = coxdata) %>% 
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "DRS probability",
    title =  paste0("DRS: All samples with adequate data (n = ", nrow(coxdata), ")"),
    #linetype = "strata",
    palette = "Dark2",
    ggtheme = theme_bw(),
    pval = T,
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

drs_ppbc$plot #Avoids printing a blank plot
```

```{r, eval=F, include=F}
resDir = here("results", "survival")
dir.create(resDir, showWarnings = F)

pdf(file.path(resDir, "04_drs_ppbc.pdf"), width = 8, height = 6)
print(drs_ppbc$plot, newpage=F)
dev.off()
```

A comparison between all groups is not significant.

```{r}
survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ PPBC, data = coxdata)
```

Pairwise log-rank tests show that none of the individual pairings are at or near significance.

```{r}
pairwise_survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ PPBC, data = coxdata)
```

## PAM50

PAM50 shows no significant variance by molecular subtype.

```{r}
drs_pam50 = 
survfit(Surv(time=months_to_drs, event=distant_recurrence) ~ PAM50, data = coxdata) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "DRS probability",
    title =  paste0("DRS: All samples with adequate data (n = ", nrow(coxdata), ")"),
    pval = T,
    palette = "Paired",
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

drs_pam50$plot
```

```{r, eval=F, include=F}
pdf(file.path(resDir, "04_drs_pam50.pdf"), width = 8, height=6)
print(drs_pam50$plot)
dev.off()
```

Log-rank test for PAM50 is similar to OS. Basal generally has a worse than expected outcome,the others match approximately with expected.

```{r}
survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ PAM50, data = coxdata)
```

Pairwise log-rank tests demonstrate that no pairing is remotely significant.

```{r}
pairwise_survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ PAM50, data = coxdata)
```

## Immune score

A higher immune score is protective for DRS as well as OS.

```{r}
drs_IS = 
survfit(Surv(time=months_to_drs, event=distant_recurrence) ~ tertile,
        data = rename(coxdata, tertile = immune_tertile)) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Distant recurrence probability",
    title = paste0("Distant recurrence by immune score (n = ", nrow(coxdata), ")"),
    pval = T,
    palette = "YlOrRd",
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

drs_IS$plot
```

```{r, eval=F, include=F}
pdf(file.path(resDir, "04_drs_immune_score.pdf"), width = 8, height=6)
print(drs_IS$plot)
dev.off()
```

```{r}
survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ immune_tertile, data = coxdata)
```

## Stromal score

As before, stromal score does not behave linearly.
The second tertile has a poorer outcome than the first or third.

```{r}
drs_SS =
survfit(Surv(time=months_to_drs, event=distant_recurrence) ~ tertile,
        data = rename(coxdata, tertile = stromal_tertile)) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "DRS probability",
    title = paste0("Distant recurrence by stromal score (n = ", nrow(coxdata), ")"),
    pval = T,
    palette = "YlOrRd",
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

drs_SS$plot
```

```{r, eval=F, include=F}
pdf(file.path(resDir, "04_drs_stromal_score.pdf"), width = 8, height=6)
print(km_SS$plot)
dev.off()
```

```{r}
survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ stromal_tertile, data = coxdata)
```

## Time in involution

Distribution of groups:

```{r}
table(inv_cox$involution)
```

```{r}
km_drs_inv = 
survfit(Surv(time=months_to_drs, event=distant_recurrence) ~ involution,
        data = inv_cox) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "DRS probability",
    title = paste0("DRS by time since weaning (n = ", nrow(inv_cox), ")"),
    pval = T,
    #palette = viridis::cividis(length(unique(inv_cox$involution))),
    palette = "Dark2",
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_drs_inv$plot

```

```{r, eval=F, include=F}
pdf(file.path(resDir, "04_drs_months_inv.pdf"), width = 8, height=6)
print(km_drs_inv$plot)
dev.off()
```

```{r}
survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ involution, data = inv_cox)
```

## Breastfeeding duration

Distribution of groups:

```{r}
table(inv_cox$breastfeeding)
```

```{r, fig.width=8, fig.height=6}
drs_brf = 
survfit(Surv(time=months_to_drs, event=distant_recurrence) ~ breastfeeding,
        data = inv_cox) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "DRS probability",
    title = paste0("DRS by breastfeeding duration (n = ", nrow(inv_cox), ")"),
    pval = T,
    palette = viridis::plasma(length(unique(inv_cox$breastfeeding))),
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

drs_brf$plot

```

```{r, eval=F, include=F}
pdf(file.path(resDir, "04_drs_breastfeeding.pdf"), width = 8, height=6)
print(drs_brf$plot)
dev.off()
```

```{r}
survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ breastfeeding, data = inv_cox)
```


# Sequential univariate analysis of clinical covariates

```{r}
#colnames(metadata)
covariates <- c("age_at_diagnosis", "year_of_diagnosis","stage","grade",
                "surgery", "radiotherapy", "hormonetherapy", "chemotherapy",
                "herceptin")
```


Of the remaining covariates, only stage and surgery are significant.

```{r}
res.simple.univ <- sapply(
  covariates,function(x) as.formula(paste('Surv(time=months_overall_survival, event=overall_survival)~', x))) %>%
  lapply(., function(x){coxph(x, data = coxdata)}) %>%
  lapply(.,
                       function(x){ 
                          x <- summary(x)
                          p.value<-signif(x$wald["pvalue"], digits=2)
                          wald.test<-signif(x$wald["test"], digits=2)
                          beta<-signif(x$coef[1], digits=2);#coeficient beta
                          HR <-signif(x$coef[2], digits=2);#exp(beta)
                          HR.confint.lower <- signif(x$conf.int[,"lower .95"], 2)
                          HR.confint.upper <- signif(x$conf.int[,"upper .95"],2)
                          HR <- paste0(HR, " (", 
                                       HR.confint.lower, "-", HR.confint.upper, ")")
                          res<-c(beta, HR, wald.test, p.value)
                          names(res)<-c("beta", "HR (95% CI for HR)", "wald.test", 
                                        "p.value")
                          return(res)
                          #return(exp(cbind(coef(x),confint(x))))
                         })
res.simple.univ <- t(as.data.frame(res.simple.univ, check.names = FALSE))
as.data.frame(res.simple.univ)
```

# Testing the proportional hazards assumption

>In principle, the Schoenfeld residuals are independent of time. A plot that shows a non-random pattern against time is evidence of violation of the PH assumption.
The proportional hazard assumption is supported by a non-significant relationship between residuals and time, and refuted by a significant relationship.
For each covariate, the function cox.zph() correlates the corresponding set of scaled Schoenfeld residuals with time, to test for independence between residuals and time.
Additionally, it performs a global test for the model as a whole.

[Source](http://www.sthda.com/english/wiki/cox-model-assumptions)

```{r}
test.ph.os <- coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis + year_of_diagnosis + grade + stage + surgery + radiotherapy + hormonetherapy + chemotherapy + herceptin + PAM50 + PPBC,
  data = coxdata) %>%
  cox.zph()
test.ph.os
```

### Year of diagnosis

The most significant problem covariate is year_of_diagnosis, which we can see trends downwards over time.

```{r}
allcov.cox = coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis + year_of_diagnosis + grade + stage + surgery + radiotherapy + hormonetherapy + chemotherapy + herceptin + PAM50 + PPBC,
  data = coxdata)

plot(test.ph.os, var = 2,
     main = paste0("Schoenfeld p: ",
                   signif(test.ph.os$table[2,3],2)))
abline(h = coef(allcov.cox)[2], col = "red", lwd = 2, lty=2)
#ggcoxzph(test.ph.os, var="year_of_diagnosis")[[1]]
```

It has a weak, non significant coefficient.

```{r}
res.simple.univ %>%
  as.data.frame() %>%
  rownames_to_column("covariate") %>%
  filter(covariate == "year_of_diagnosis")
```
We can safely discard this covariate.

Run the model again without it and test for PH assumptions.

```{r}
adj.cov.cox <- coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis + grade + stage + surgery + radiotherapy + hormonetherapy + chemotherapy + herceptin + PAM50 + PPBC,
  data = coxdata)
cox.zph(adj.cov.cox)
```

## Treatment interventions

Several of the various treatment interventions violate the proportional hazards assumption.

Chemotherapy treands weakly downward over time, whereas hormonetherapy trends weakly upward over time.

```{r}
par(mfrow= c(1,2))
#Chemo
plot(test.ph.os, var = 8,
     main = paste0("Schoenfeld p: ",
                   signif(test.ph.os$table[8,3],2)))
abline(h = coef(allcov.cox)[8], col = "red", lwd = 2, lty=2)
#ggcoxzph(test.ph.os, var="chemotherapy")[[1]]

#Hormone
plot(test.ph.os, var = 7,
     main = paste0("Schoenfeld p: ",
                   signif(test.ph.os$table[7,3],2)))
abline(h = coef(allcov.cox)[7], col = "red", lwd = 2, lty=2)
#ggcoxzph(test.ph.os, var="hormonetherapy")[[1]]

```

In both cases, the trend appears to be largely driven by outliers.
This makes sense as some patients will be more or less responsive to different treatments.

These covariates are stronger, albeit not significant, and in any case we cannot simply discard some interventions.

```{r}
res.simple.univ %>%
  as.data.frame() %>%
  rownames_to_column("covariate") %>%
  filter(covariate %in% c("chemotherapy", "hormonetherapy"))
```

Can we render treatment interventions compliant with the proportional hazards assumption by collapsing it into a single factor?

```{r}
coxdata2 = coxdata %>% mutate(
  surgery = if_else(surgery == 1, "surgeryYes", "surgeryNo"),
  radiotherapy = if_else(radiotherapy == 1, "radiotherapyYes", "radiotherapyNo"),
  hormonetherapy = if_else(hormonetherapy == 1, "hormonetherapyYes", "hormonetherapyNo"),
  chemotherapy = if_else(chemotherapy == 1, "chemotherapyYes", "chemotherapyNo"),  
  herceptin = if_else(herceptin == 1, "herceptinYes", "herceptinNo")
) %>% mutate(
  treatment = paste(surgery, radiotherapy, hormonetherapy,
                    chemotherapy, herceptin, sep = ":"))#%>% select(-surgery:-herceptin)

#table(coxdata2$treatment)

coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis + grade + stage + treatment + PAM50 + PPBC,
  data = coxdata2) %>%
  cox.zph()


```

No, because the groups are too small.

If we stratify these variables, we remove the problem.

```{r}
coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis + grade + stage + surgery + radiotherapy + strata(hormonetherapy) + strata(chemotherapy) + herceptin + PAM50 + PPBC,
  data = coxdata) %>%
  cox.zph()

```

## PAM50

The trend over time appears to be largely driven by outliers. 
However, since this is a categorical variable, the trend is harder to interpret.

```{r}
plot(test.ph.os, var = 10,
     main = paste0("Schoenfeld p: ",
                   signif(test.ph.os$table[10,3],2)))
abline(h = coef(allcov.cox)[10], col = "red", lwd = 2, lty=2)
```

No individual level of PAM50 is significant compared to Basal, but for biological reasons, we cannot simply discard this covariate.
It's too strong a signal in breast cancer to ignore.

```{r}
coxph(Surv(time=months_overall_survival, event=overall_survival) ~ PAM50, data = coxdata)

```

Since we aren't interested in assessing the individual effect of PAM50 on survival, we can simply stratify it.

```{r}
coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis + grade + stage + surgery + radiotherapy + strata(hormonetherapy) + strata(chemotherapy) + herceptin + strata(PAM50) + PPBC,
  data = coxdata) %>%
  cox.zph()
```

## Stage

Stage is just barely not sigificant when looking at Schoenfeld residuals.

```{r}
#plot(test.ph.os, var = 4,
#     main = paste0("Schoenfeld p: ",
#                   signif(test.ph.os$table[4,3],2)))
#abline(h = coef(allcov.cox)[4], col = "red", lwd = 2, lty=2)
ggcoxzph(test.ph.os, var="stage")[[1]]
```
However, the Schoenfeld individual test is no logner significant after the other problem covariates have been stratified, as we saw in the previous section.
No further action is taken here.

# Testing influential observations

>Specifying the argument type = “dfbeta”, plots the estimated changes in the regression coefficients upon deleting each observation in turn; likewise, type=“dfbetas” produces the estimated changes in the coefficients divided by their standard errors.

Although some notable outliers are present for nearly every covaraite, the points are relatively evenly distributed around the center for all save PPBC-pregnancy.
This cannot be corrected for without discarding some samples, which is not warranted based on these plots.

```{r, fig.width=7, fig.height=10}
coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis + grade + stage + surgery + radiotherapy + hormonetherapy + chemotherapy + herceptin + PAM50 + PPBC,
  data = coxdata) %>%
ggcoxdiagnostics(., type = "dfbeta",
                 linear.predictions = FALSE, ggtheme = theme_bw())
```

# Multivariate Cox models

After diagnostics, we discard year of diagnosis and stratify hormonetherapy, chemotherapy and PAM50.

Kaplan-Meier curves produced in this section will be corrected via the conditional method of `ggadjustedcurves()` from the `survminer` package.

>For method = “conditional” a separate survival curve is plotted for each level of a grouping variable selected by variable argument. If this argument is not specified, then it will be extracted from the strata component of fit object. Subpopulations are balanced in a following way: (1) the data is replicated as many times as many subpopulations are considered (say k), (2) for each row in original data a set of k copies are created and for every copy a different value of a grouping variable is assigned, this will create a new dataset balanced in terms of grouping variables, (3) expected survival is calculated for each subpopulation based on the new artificial dataset. Here the model fit is not refitted.

[Source](https://github.com/kassambara/survminer/blob/master/R/ggadjustedcurves.R)

When displaying p values for these plots, we perform an anova with a reduced model that lacks the covariate of interest.

## Adjusting for clinical covariates

Advanced stage and PPBC involuting patients have a significantly worse outcome. 
Patients who undergo surgery have a significantly better outcome.

```{r}
clin.cov.cox <- coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis +
    grade +
    stage +
    surgery +
    radiotherapy +
    strata(hormonetherapy) +
    strata(chemotherapy) +
    herceptin +
    strata(PAM50) +
    PPBC,
  data = coxdata)
summary(clin.cov.cox)
```

It is worth noting that all but 7 patients underwent surgery, so it is likely that those patients who were inelligble were at an advanced stage of disease progression at diagnosis.

```{r}
table(coxdata$surgery)
```

### KM adjusted overall survival

Stratifying treatment prior to ggadjusted curves results in several strata with zero non-NA points. 
We'll remove the stratification from this analysis.

```{r}
fit1 = coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis +
    grade +
    stage +
    surgery +
    radiotherapy +
    hormonetherapy +
    chemotherapy +
    herceptin +
    strata(PAM50) +
    #PAM50 +
    PPBC,
  data = coxdata)

fit0 = coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis +
    grade +
    stage +
    surgery +
    radiotherapy +
    hormonetherapy +
    chemotherapy +
    herceptin +
    strata(PAM50)
    #PAM50
  ,
  data = coxdata)

km_ppbc_os_adj = ggadjustedcurves(fit1, variable = "PPBC",
                                  data = coxdata, method="conditional",
                                  palette = color_palettes$ppbc_colors,
                                  ggtheme = theme_bw()) +
  ggtitle("Overall survival adjusted for clinical covariates") +
  annotate(geom = "text",
           label = paste("p =", signif(anova(fit1, fit0)[4][2,], 2)),
           x= 25, y =0.1)

km_ppbc_os_adj
```

```{r, eval=F, include=F}
pdf(file.path(resDir, "04_os_ppbc_adjusted.pdf"), width = 8, height=6)
print(km_ppbc_os_adj)
dev.off()
```

For distant recurrence, stage remains significantly deleterious while surgery is significantly protective.
Involuting patients are not significantly worse off.

```{r}
drs.clin.cov.cox <- coxph(
  Surv(time=months_to_drs,
       event=distant_recurrence) ~ age_at_diagnosis +
    grade +
    stage +
    surgery +
    radiotherapy +
    strata(hormonetherapy) +
    strata(chemotherapy) +
    herceptin +
    strata(PAM50) +
    PPBC,
  data = coxdata)
summary(drs.clin.cov.cox)
```

### KM adjusted distant recurrence

```{r}
fit1 = coxph(
  Surv(time=months_to_drs,
       event=distant_recurrence) ~ age_at_diagnosis +
    grade +
    stage +
    surgery +
    radiotherapy +
    hormonetherapy +
    chemotherapy +
    herceptin +
    strata(PAM50) +
    #PAM50 +
    PPBC,
  data = coxdata)

fit0 = coxph(
  Surv(time=months_to_drs,
       event=distant_recurrence) ~ age_at_diagnosis +
    grade +
    stage +
    surgery +
    radiotherapy +
    hormonetherapy +
    chemotherapy +
    herceptin +
    strata(PAM50)
    #PAM50
  ,
  data = coxdata)

km_ppbc_drs_adj = ggadjustedcurves(fit1, variable = "PPBC",
                                  data = coxdata, method="conditional",
                                  palette = color_palettes$ppbc_colors,
                                  ggtheme = theme_bw()) +
  ggtitle("Distant recurrence adjusted for clinical covariates") +
  annotate(geom = "text",
           label = paste("p =", signif(anova(fit1, fit0)[4][2,], 2)),
           x= 25, y =0.1)

km_ppbc_drs_adj
```

```{r, eval=F, include=F}
pdf(file.path(resDir, "04_drs_ppbc_adjusted.pdf"), width = 8, height=6)
print(km_ppbc_drs_adj)
dev.off()
```

## Adjused models for immune and stromal scores

After adjusting for clinical covariates, immune tertile is significantly protective, especially for DRS.
Stromal tertile is not.

```{r}
coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis +
    grade +
    stage +
    surgery +
    radiotherapy +
    strata(hormonetherapy) +
    strata(chemotherapy) +
    herceptin +
    strata(PAM50) +
    PPBC +
    stromal_tertile +
    immune_tertile,
  data = coxdata) %>% summary()

coxph(
  Surv(time=months_to_drs,
       event=distant_recurrence) ~ age_at_diagnosis +
    grade +
    stage +
    surgery +
    radiotherapy +
    strata(hormonetherapy) +
    strata(chemotherapy) +
    herceptin +
    strata(PAM50) +
    PPBC +
    stromal_tertile +
    immune_tertile,
  data = coxdata) %>% summary()

```

### KM adjusted immune

Plotting OS only.

```{r}
names(tertile_colors) = c(1,2,3)

fit1 = coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis +
    grade +
    stage +
    surgery +
    radiotherapy +
    hormonetherapy +
    chemotherapy +
    herceptin +
    strata(PAM50) +
    #PAM50 +
    immune_tertile,
  data = coxdata)

fit0 = coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis +
    grade +
    stage +
    surgery +
    radiotherapy +
    hormonetherapy +
    chemotherapy +
    herceptin +
    strata(PAM50)
    #PAM50
  ,
  data = coxdata)

km_ppbc_adj_immune = ggadjustedcurves(fit1, variable = "immune_tertile",
                                  data = coxdata, method="conditional",
                                  palette = tertile_colors,
                                  ggtheme = theme_bw()) +
  ggtitle("Overall survival of ESTIMATE immune scores, adjusted for clinical covariates") +
  annotate(geom = "text",
           label = paste("p =", signif(anova(fit1, fit0)[4][2,], 2)),
           x= 25, y =0.1) +
  labs(color = "tertile")

km_ppbc_adj_immune
```

### KM adjusted stromal

```{r}
names(tertile_colors) = c(1,2,3)

fit1 = coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis +
    grade +
    stage +
    surgery +
    radiotherapy +
    hormonetherapy +
    chemotherapy +
    herceptin +
    strata(PAM50) +
    #PAM50 +
    stromal_tertile,
  data = coxdata)

fit0 = coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis +
    grade +
    stage +
    surgery +
    radiotherapy +
    hormonetherapy +
    chemotherapy +
    herceptin +
    strata(PAM50)
    #PAM50
  ,
  data = coxdata)

km_ppbc_adj_stromal = ggadjustedcurves(fit1, variable = "stromal_tertile",
                                  data = coxdata, method="conditional",
                                  palette = tertile_colors,
                                  ggtheme = theme_bw()) +
  ggtitle("Overall survival of ESTIMATE stromal scores, adjusted for clinical covariates") +
  annotate(geom = "text",
           label = paste("p =", signif(anova(fit1, fit0)[4][2,], 2)),
           x= 25, y =0.1) +
  labs(color = "tertile")

km_ppbc_adj_stromal
```

```{r, eval=F, include=F}
#pdf(file.path(resDir, "04_os_ppbc_adjusted.pdf"), width = 8, height=6)
#print(km_ppbc_os_adj)
#dev.off()
```

## Adjused models for time in involution and breastfeeding

As continuous variables, neither involution duration nor breastfeeding duration is significant.
It doesn't matter whether we look at OS or DRS.

```{r}
coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis +
    grade +
    stage +
    surgery +
    radiotherapy +
    strata(hormonetherapy) +
    strata(chemotherapy) +
    herceptin +
    strata(PAM50) +
    months_involution_breastfeeding +
    breastfeeding_months,
  data = inv_cox) %>% summary()

coxph(
  Surv(time=months_to_drs,
       event=distant_recurrence) ~ age_at_diagnosis +
    grade +
    stage +
    surgery +
    radiotherapy +
    strata(hormonetherapy) +
    strata(chemotherapy) +
    herceptin +
    strata(PAM50) +
    months_involution_breastfeeding +
    breastfeeding_months,
  data = inv_cox) %>% summary()
```

As categorical variables, a shorter time in involution (< 2 months) or breastfeeding (1 < month) is significantly worse than a longer duration in either.
Interestingly, this is ONLY true for DRS.

```{r}
coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis +
    grade +
    stage +
    surgery +
    radiotherapy +
    strata(hormonetherapy) +
    strata(chemotherapy) +
    herceptin +
    strata(PAM50) +
    involution +
    breastfeeding,
  data = inv_cox) %>% summary()

coxph(
  Surv(time=months_to_drs,
       event=distant_recurrence) ~ age_at_diagnosis +
    grade +
    stage +
    surgery +
    radiotherapy +
    strata(hormonetherapy) +
    strata(chemotherapy) +
    herceptin +
    strata(PAM50) +
    involution +
    breastfeeding,
  data = inv_cox) %>% summary()

```

There are too few samples to plot adjusted Kaplan-Meier curves.

# Save data

Write all Kaplain-Meiers to a pdf.
They will be either gg or ggsurvplot objects

```{r}
kms = sapply(ls(), function(x) class(get(x)))%>%
  unlist() %>%
  enframe() %>%
  filter(value %in% c("gg", "ggsurvplot")) %>%
  pull(name)

kms = kms %>% str_sub(1, -2)

for(km in kms){
  print(km)
}
```

Choose the order in the pdf

```{r}
resDir = here("results", "survival")
dir.create(resDir, showWarnings = F)

pdf(file.path(resDir, "04_kaplan_meiers.pdf"),
    onefile = T,
    width = 8, height = 6)
print(km_ppbc$plot, newpage=F)
print(km_ppbc_os_adj)
print(drs_ppbc$plot)
print(km_ppbc_drs_adj)
print(km_pam50$plot)
print(drs_pam50$plot)
print(km_time_inv$plot)
print(km_drs_inv$plot)
print(km_brf$plot)
print(drs_brf$plot)
print(km_IS$plot)
print(drs_IS$plot)
print(km_ppbc_adj_immune)
print(km_SS$plot)
print(drs_SS$plot)
print(km_ppbc_adj_stromal)
dev.off()
```

Immune score and stromal score are already in the coldata.
We should add the tertiles for ESTIMATE and breastfeeding

```{r}
dds$immune_tertile = dplyr::ntile(as.data.frame(colData(dds))$immune_score, 3)
dds$stromal_tertile = dplyr::ntile(as.data.frame(colData(dds))$stromal_score, 3)

#We want this for all samples, even those excluded from Cox analysis
cd = as.data.frame(colData(dds))
cd = cd %>%
  mutate(involution = case_when(
    months_involution_breastfeeding < 2 ~ "< 2 months",
    months_involution_breastfeeding >= 2 ~ "> 2 months"
    )) %>% 
  mutate(involution = factor(involution,
                             levels = c("< 2 months", "> 2 months"))) %>%
  mutate(breastfeeding = case_when(
    breastfeeding_months < 1 & study_group == "ppbc_inv" ~ "< 1 month",
    between(breastfeeding_months, 1, 4) & study_group == "ppbc_inv" ~ "1-4 months",
    between(breastfeeding_months, 5, 29) & study_group == "ppbc_inv" ~ "5-29 months"
  )) %>%
  select(sample_name, months_involution_breastfeeding, involution,
         breastfeeding_months, breastfeeding, everything()) %>%
  mutate(breastfeeding = factor(breastfeeding,
                                levels = c("< 1 month", "1-4 months",
                                           "5-25 months")))
stopifnot(identical(cd$sample_name, colData(dds)$sample_name))

dds$involution_duration = cd$involution
dds$breastfeeding_duration = cd$breastfeeding
```

Write both the coldata and the new dds object

```{r}
write.csv(as.data.frame(colData(dds)),
          file=here("data","metadata", "04_sample_annot_filtered_PAM50_EST.csv"), row.names = F)
saveRDS(dds, file=here("data","Rds","04_dds_PAM50_EST.Rds"))
```


```{r}
save.image(here("reports","04_survival_and_ESTIMATE.RData"))
```

# Session info

```{r}
sessionInfo()
```

