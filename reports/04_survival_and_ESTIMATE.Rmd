---
title: "Survival and ESTIMATE"
date: "`r Sys.Date()`"
author: "Kat Moore"
output: 
  html_document:
    toc: yes
    toc_float: yes
    toc_depth: 4
    highlight: tango
    df_print: paged
---

```{r, include=F}
rm(list = ls())
```

```{r, include=F}
library(DESeq2)
library(here)
library(estimate)
library(tidyverse)
library(survival)
library(survminer)
library(ggthemes)
library(RColorBrewer)
library(ggpubr)
```

```{r Default ggplot themes, include=F}
options(ggplot2.continuous.colour = "viridis")
options(ggplot2.continuous.fill = "viridis")
scale_colour_discrete <- scale_color_colorblind
#scale_colour_discrete <- scale_colour_viridis_d

#For fill
#viridis_qualitative_pal7 <- c("#440154FF", "#FDE725FF", "#443A83FF", 
#                              "#8FD744FF", "#31688EFF",  "#35B779FF", 
#                              "#21908CFF")

scale_fill_discrete <- function(...) {
  #scale_fill_manual(..., values = viridis_pal()(7)) #Wrong order
  #scale_fill_manual(..., values = viridis_qualitative_pal7)
  scale_fill_manual(..., values = colorblind_pal()(8))
}

theme_set(theme_minimal())
```

In this notebook, we use ESTIMATE to calculate immune/stromal scores and tumor purity for the PPBC dataset.
Several survival analyses are also performed.

# Load data

```{r}
dds <- readRDS(here("data/Rds/03_dds_PAM50.Rds"))

tx_annot <- read_tsv(here("data/metadata/01_tx_annot.tsv"))
```

We only need the gene id and hgnc symbol for this script.

```{r}
tx_annot = tx_annot %>%
  select(gene_id, hgnc_symbol) %>%
  distinct()
```

# Conversion to FPKM with HUGO symbols

Esimate requires transcript length normalization and gene names instead of ensembl ids.

Debatable: whether to use robust = T or F when calculating fpkm for the purposes of determining tumor purity with Estimate. 
When True, estimateSizeFactors is called to more accurately normalize by library size. 
Use the robust = F option to disable the median ratio normalization and just get classical fpkm via colSums.

Since we prefer a more robust correction for library size, choose robust = T.

```{r}
fpkm <- DESeq2::fpkm(dds, robust = T)
```

Add the HUGO symbols

```{r}
fpkm <- fpkm %>%
  as.data.frame() %>%
  rownames_to_column("gene_id") %>%
  right_join(select(tx_annot, gene_id, hgnc_symbol),
             .,
             by = "gene_id")
```

Make sure we don't have any NAs in the HGNC field.

```{r}
print(paste("Removing",
            sum(is.na(fpkm$hgnc_symbol)),
            "genes without HUGO ids from the fpkm matrix."))

fpkm <- fpkm %>% filter(!is.na(hgnc_symbol))
```

```{r}
print(paste(nrow(fpkm), "genes remaining in the fpkm matrix."))
```

Drop the ensembl id column.

```{r}
fpkm <- fpkm %>% select(-gene_id)
```

# De-duplicate gene symbols

When dealing with duplicated gene names, take the mean fpkm.

```{r}
summarize_expression_duplicate_ids <- function(mat, id_column, f=colMeans,
                                               final_gene_symbol_colname="GeneSymbol"){
  require(dplyr)
  
  print(paste("Starting with gene expression matrix containing", nrow(mat), "rows."))
  
  #Easiest way to write functions with dplyr is to standardize the column name
  
  if(id_column != "symbol"){
    colnames(mat)[colnames(mat)==id_column] <- "symbol"
  }
  
  #Make frequency table
  id_table <- as.data.frame(table(mat$symbol))
  
  #Identify duplicate genes
  dups <- id_table$Var1[id_table$Freq > 1]
  stopifnot(length(dups) == length(unique(dups)))
  print(paste("Number of genes with duplicate names:", length(dups)))
  
  #Set aside rows with unique gene names
  nodup_df <- mat[!mat$symbol %in% dups,]
  
  #Set aside rows with duplicate ids
  dup_df <- mat[mat$symbol %in% dups,]
  stopifnot(nrow(nodup_df) + nrow(dup_df) == nrow(mat))
  
  #Sort by recurring id
  dup_df <- dup_df[order(dup_df$symbol),]
  
  print(paste("Number of rows with duplicate gene ids:", nrow(dup_df)))
  
  #Mean expression fpkm of genes with the same symbol
  mean_exps <- matrix(ncol = ncol(dup_df)-1, nrow=0) #Empty matrix, -1 gene symbol column

  for (i in 1:length(unique(dup_df$symbol))){
    #Subset rows with same symbol, discard symbol column, then apply aggregate function
    exp <- f(as.matrix(dup_df[dup_df$symbol==unique(dup_df$symbol)[i], -1])) 
    mean_exps <- rbind(mean_exps, exp)
  }
  stopifnot(nrow(mean_exps) == length(unique(dup_df$symbol)))
  
  rownames(mean_exps) <- unique(dup_df$symbol)
  mean_exps <- as.data.frame(mean_exps) %>% rownames_to_column("symbol")
  
  dedupped_df <- rbind(mean_exps, nodup_df)
  dedupped_df <- dedupped_df[order(dedupped_df$symbol),]
  
  stopifnot(length(unique(dedupped_df$symbol))==length(dedupped_df$symbol)) #All symbols should not be unique
  stopifnot(nrow(mat) - #starting number
            nrow(dup_df) + #rows with duplicate genes...
            length(dups) == #...which condense down into this many unique genes...
            nrow(dedupped_df)) #...should equal the number of rows in the final matrix

  print(paste("Number of genes after applying", substitute(f),  "to duplicate ids:", nrow(dedupped_df)))
  
  #For estimate, the column with identifiers HAS to be called GeneSymbol or EntrezGeneID
  colnames(dedupped_df)[colnames(dedupped_df)=="symbol"] <- final_gene_symbol_colname
  
  return(dedupped_df)
}
```

```{r}
clean_fpkm <- summarize_expression_duplicate_ids(fpkm, "hgnc_symbol")
```

```{r}
head(clean_fpkm)
```

The input for ESTIMATE can supposedly be a dataframe, but the function throws an error unless provided with a file..

```{r}
write.table(clean_fpkm, sep = "\t", file = here("data","RNA-seq","hugo_fpkm.txt"), col.names = T, row.names =F, quote=F)
```

# ESTIMATE

Estimate really only has two functions of interest for us. 
The first is filterCommonGenes, which unifies genes symbols provided versus the 10,412 used for determining tumor purity.

It requires writing a file instead of returning an object within the R environment. 

```{r}
dir.create(here("results","ESTIMATE"), showWarnings = F)

filterCommonGenes(input.f=here("data","RNA-seq","hugo_fpkm.txt"),
                  output.f = here("results","ESTIMATE","filterCommonGenes.gct"), id="GeneSymbol")
```

The next function computes stromal, immune, and ESTIMATE scores per sample using gene expression data. It also insists on writing files.

```{r}
estimateScore(input.ds = here("results","ESTIMATE","filterCommonGenes.gct"),
              output.ds = here("results","ESTIMATE","results_estimate_score.gct"),
              platform="illumina")
```

```{r}
scores <- read.delim(here("results","ESTIMATE","results_estimate_score.gct"), skip=2, sep="\t")
scores[,1:6]
```

## Purity score calculation

Note: Only validated for microarray data:
Tumour purity=cos (0.6049872018+0.0001467884 Ã— ESTIMATE score)
[Source](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3826632/)

```{r}
purity_score <- scores %>%
  dplyr::select(-Description) %>%
  rename(score=NAME) %>%
  gather(key="sample_name", -score, value=value) %>%
  mutate(sample_name=str_replace_all(sample_name, "\\.","-")) %>%
  spread(key=score,value=value) %>%
  mutate(tumor_purity = cos(0.6049872018+0.0001467884 * ESTIMATEScore))
```

# Stromal and Immune Scores

## General

Bar plot

```{r}
scores %>% dplyr::select(-Description) %>%
  gather(key = "sample_name", -NAME, value="Score") %>%
  left_join(., as.data.frame(colData(dds)), by="sample_name") %>%
  arrange(PPBC) %>%
  ggplot(aes(x=factor(sample_name, levels = unique(sample_name)),y=Score, fill=PPBC)) +
  geom_bar(stat="identity") +
  facet_wrap(~NAME, ncol=1) +
  theme(axis.text.x=element_blank()) +
  xlab("Samples")
``` 

Box plots

```{r}
scores %>% dplyr::select(-Description) %>%
  gather(key = "sample_name", -NAME, value="Score") %>%
  left_join(., as.data.frame(colData(dds)), by="sample_name") %>%
  filter(NAME != "ESTIMATEScore") %>%
  ggplot(aes(x=PPBC,y=Score, color=PPBC)) +
  geom_boxplot(alpha = 0) +
  ggbeeswarm::geom_quasirandom(method="smile") +
  facet_wrap(~NAME, ncol=2) +
  theme(legend.position = "none")
  #xlab("Samples")
```

## Immune scores

```{r}
comps <- list( c("nulliparous", "involuting"),
               c("lactating", "involuting"),
               c("pregnant", "involuting") )


immune_df = scores %>% dplyr::select(-Description) %>%
  gather(key = "sample_name", -NAME, value="Score") %>%
  left_join(., as.data.frame(colData(dds)), by="sample_name") %>%
  filter(NAME == "ImmuneScore") 

immune_df %>%
  ggboxplot(x="PPBC", y="Score", add="dotplot", 
          color = "PPBC", notch = T) +
  theme(legend.position = "none") +
  ggtitle("Immune Score by study group") + 
  stat_compare_means(comparisons = comps)+ 
  stat_compare_means(label.y = 3500)
```

```{r}
comps <- list( c("Basal", "LumA"),
               c("Basal", "LumB"),
               c("Basal", "Her2"),
               c("Basal", "Normal"))

immune_df %>%
  ggboxplot(x="PAM50", y="Score", add="dotplot", 
          color = "PAM50", notch = F,
          order = c("LumA", "LumB", "Basal", "Her2", "Normal")) +
  theme(legend.position = "none") +
  ggtitle("Immune Score by PAM50") + 
  stat_compare_means(comparisons = comps)+ 
  stat_compare_means(label.y = 3500)
```

## Stromal Scores

```{r}
comps <- list( c("nulliparous", "involuting"),
               c("lactating", "involuting"),
               c("pregnant", "involuting") )


stromal_df <- scores %>% dplyr::select(-Description) %>%
  gather(key = "sample_name", -NAME, value="Score") %>%
  left_join(., as.data.frame(colData(dds)), by="sample_name") %>%
  filter(NAME == "StromalScore") 

stromal_df %>%
  ggboxplot(x="PPBC", y="Score", add="dotplot", 
          color = "PPBC", notch = T) +
  theme(legend.position = "none") +
  ggtitle("Stromal Score by study group") + 
  stat_compare_means(comparisons = comps)+ 
  stat_compare_means(label.y = 2500)
```

```{r}
comps <- list( c("Basal", "LumA"),
               c("Basal", "LumB"),
               c("Basal", "Her2"),
               c("Basal", "Normal"))

stromal_df %>%
  ggboxplot(x="PAM50", y="Score", add="dotplot", 
          color = "PAM50", notch = F,
          order = c("LumA", "LumB", "Basal", "Her2", "Normal")) +
  theme(legend.position = "none") +
  ggtitle("Stromal Score by PAM50") + 
  stat_compare_means(comparisons = comps)+ 
  stat_compare_means(label.y = 2500)
```

# Survival setup

Add immune, stromal and tumor purity to metadata

```{r}
stopifnot(all(colData(dds)$sample_name == purity_score$sample_name))
dds$immune_score = purity_score$ImmuneScore
dds$stromal_score = purity_score$StromalScore
dds$tumor_purity = purity_score$tumor_purity
```

## Prepare metadata

Covariates: grade, stage, molecular subtype, age at diagnosis, year of diagnosis, therapy type(s)

We will try to keep the columns of the metadata as consistent as possible between versions.

```{r}
sd = as.data.frame(colData(dds))
sd = sd %>%
  select(sample_name, patient_ref, reason_death, 
         study_group, PPBC, PAM50,
         grade = grade_integer, stage = stage_short_integer,
         months_of_followup, year_of_diagnosis = year_diagnosis,
         age_at_diagnosis = age_diagnosis, metastasis_at_diagnosis,
         overall_survival, months_overall_survival,
         distant_recurrence, months_to_drs, surgery,
         radiotherapy = RT, hormonetherapy = HT,
         chemotherapy = CT, herceptin = HERC
         )

sd %>% head()
```

How many samples lack complete info?

In total 15 such samples are excluded.

```{r}
samples_missing_info <- sd[rowSums(is.na(sd))> 0,]

samples_missing_info
```

```{r}
write_csv(samples_missing_info,
          here("data/metadata/04_samples_with_missing_survival_data.csv"))
```


## Excluded samples

Exclude samples for which there has been less than 20 months of follow up, unless the reason for the lack of follow up is that the patient passed away due to disease (and not an accident or suicide).

In this version, non-BC deaths have been already filtered out

```{r}
unique(sd$reason_death)
```

follow_up > 20 | death == 1

```{r, collapse=T}
print(paste("Started with", nrow(sd), "samples"))

print(paste("Samples with missing values in survival data:",
            length(samples_missing_info)))
excluded = sd %>% filter(sample_name %in% samples_missing_info$sample_name) %>%
  mutate(reason = "missing survival data")

print(paste("Samples excluded due to patient death unrelated to disease:",
            nrow(sd %>% filter(!reason_death %in% c("alive", "BC")))))

excluded = bind_rows(excluded,
                     mutate(filter(sd, !reason_death %in% c("alive", "BC")),
                            reason = "unrelated death")
                     )

print(paste("Samples excluded due to insufficient follow up:",
      nrow(sd %>% filter(months_of_followup < 20 & reason_death == "BC"))))

excluded = bind_rows(excluded,
                     mutate(filter(sd, months_of_followup < 20 & reason_death == "BC"),
                            reason = "insufficient followup"))

metadata = sd %>% filter(!sample_name %in% samples_missing_info$sample_name) %>%
  filter(reason_death %in% c("alive", "BC")) %>%
  filter(months_of_followup >= 20 | reason_death == "BC")

print(paste(nrow(metadata), "samples remaining post filtering"))

stopifnot(all(rowSums(is.na(metadata)) == 0))
```

Save metadata

```{r}
write_csv(metadata,
          path = here("data", "metadata", "04_survival_metadata.csv"))
```

Overview excluded samples:

```{r}
excluded = select(excluded, reason, everything()) %>% arrange(sample_name)

table(excluded$sample_name, excluded$reason)

openxlsx::write.xlsx(list(overview = table(excluded$sample_name, excluded$reason),
                          metadata_excluded_samples = excluded),
                          here("data/metadata/04_samples_excluded_survival.xlsx"))
```

We will not be using genes as features in this notebook: those analyses will come later.
The metadata as prepared can be used as input for survival analyses.

```{r}
coxdata = metadata
saveRDS(coxdata, here("data/Rds/04_survdata.Rds"))
```

# Univariate survival curves

Kaplan-meier curves with univariate design (not correcting for clinical covariates).

## Set up tertiles

Define tertiles for immune and stromal scores when plotting.

```{r calculate tertiles}
immune_df$tertile = dplyr::ntile(immune_df$Score, 3)
stromal_df$tertile = dplyr::ntile(stromal_df$Score, 3)

bind_rows(immune_df, stromal_df) %>%
  ggplot(aes(x = NAME, y = Score, color = as.factor(tertile))) +
  geom_jitter() +
  #geom_boxplot(alpha = 0) +
  xlab("") +
  labs(color = "tertile") +
  ggtitle("Distribution of immune and stromal score by tertile")

```

```{r add tertitles to metadata}
coxdata = right_join(
  select(immune_df, sample_name, immune_tertile = tertile),
  coxdata, by = "sample_name")
coxdata = right_join(
  select(stromal_df, sample_name, stromal_tertile = tertile),
  coxdata, by = "sample_name")

coxdata = coxdata %>%
  select(sample_name:PAM50, immune_tertile, stromal_tertile, everything())
```

Subset the data down to involution only samples for analyses related to breastfeeding.
Add months_involution_breastfeeding (the number of months since the onset of weaning) and breastfeeding_months (the number of months of breastfeeding before stopping) to the coxdata.
Omit missing values.

```{r}
inv_cox = as.data.frame(colData(dds)) %>%
  filter(study_group == "ppbc_inv") %>%
  select(sample_name, months_involution_breastfeeding, breastfeeding_months) %>%
  na.omit() %>%
  left_join(., coxdata, by = "sample_name") %>%
  na.omit()

print(paste(nrow(inv_cox), "of", nrow(filter(coxdata, study_group == "ppbc_inv")),
            "involution samples with complete metadata have breastfeeding and time since weaning"))
```

```{r}
inv_cox %>%
  select(sample_name, months_involution_breastfeeding, breastfeeding_months) %>%
  gather(key = "type", -sample_name, value = "months") %>%
  ggplot(aes(x = months, fill = type)) +
  geom_density(alpha = 0.5) +
  ggtitle("Distribution of breastfeeding and involution duration")
```
Set up duration categories



```{r}
inv_cox = inv_cox %>%
  mutate(involution = case_when(
    months_involution_breastfeeding < 2 ~ "< 2 months",
    between(months_involution_breastfeeding, 2, 6) ~ "2-6 months",
    between(months_involution_breastfeeding, 7, 12) ~ "7-12 months",
    between(months_involution_breastfeeding, 13, 25) ~ "13-25 months",
  )) %>% mutate(breastfeeding = case_when(
    breastfeeding_months < 1 ~ "< 1 month",
    between(breastfeeding_months, 1, 4) ~ "1-4 months",
    between(breastfeeding_months, 5, 25) ~ "5-25 months"
  )) %>%
  select(sample_name, months_involution_breastfeeding, involution,
         breastfeeding_months, breastfeeding, everything()) %>%
  mutate(involution = factor(involution,
                             levels = c("< 2 months", "2-6 months",
                                        "7-12 months", "13-25 months")),
         breastfeeding = factor(breastfeeding,
                                levels = c("< 1 month", "1-4 months",
                                           "5-25 months")))

inv_cox$involution %>% table()
inv_cox$breastfeeding %>% table()
```

```{r, include=F}
#Define study group/PPBC colors
study_colors=suppressWarnings(colorRampPalette(brewer.pal(length(unique(sd$study_group)) + 1,"Spectral"))(length(unique(sd$study_group)) + 1))
names(study_colors) = c(as.character(unique(sd$study_group)), "rest")
ppbc_colors=study_colors
dict = rbind(distinct(select(sd, study_group, PPBC)),
             tibble(study_group = "rest", PPBC = "rest"))
names(ppbc_colors) = paste0("PPBC=", dict$PPBC[match(names(study_colors), dict$study_group)])

#Define PAM50 colors
pam_colors = suppressWarnings(colorRampPalette(brewer.pal(length(unique(sd$PAM50)),"Paired"))(length(unique(sd$PAM50))))
names(pam_colors)= unique(sd$PAM50)

#Define stromal and immune colors
#est_colors = c(suppressWarnings(colorRampPalette(brewer.pal(3,"YlGnBu"))(3)),
#               suppressWarnings(colorRampPalette(brewer.pal(3,"PuBuGn"))(3)))
#scales::show_col(est_colors)
```

## PPBC

Lactation shows the worst prognosis, followed by involution.

```{r, fig.width = 8}
km_ppbc = survfit(Surv(time=months_overall_survival, event=overall_survival) ~ PPBC, data = coxdata) %>% 
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = paste0("OS: All samples with adequate data (n = ", nrow(coxdata), ")"),
    #palette = ppbc_colors[-5],
    palette = "Dark2",
    #linetype = "strata",
    #conf.int = T,
    pval = T,
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_ppbc$plot #Avoids printing a blank plot
```

```{r, echo=F, include=F}
resDir = here("results", "survival")
dir.create(resDir, showWarnings = F)

pdf(file.path(resDir, "04_km_ppbc.pdf"), width = 8, height = 6)
print(km_ppbc$plot, newpage=F)
dev.off()
```

Survdiff implements the log-rank test, which compares one or more curves vs the null hypothesis that there is no difference in survival between the curves. 
The log-rank statistic is chi-square distributed.

A comparison between all groups is near but not quite significant.

```{r}
survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ PPBC, data = coxdata)
```

Pairwise log-rank tests show that none of the individual pairings are significant.

```{r}
pairwise_survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ PPBC, data = coxdata)
```

## PAM50

PAM50 shows no significant variance by molecular subtype.

```{r}
km_pam50 = 
survfit(Surv(time=months_overall_survival, event=overall_survival) ~ PAM50, data = coxdata) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = paste0("OS: All samples with adequate data (n = ", nrow(coxdata), ")"),
    pval = T,
    palette = "Paired",
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_pam50$plot
```

```{r, echo=F, include=F}
pdf(file.path(resDir, "04_km_pam50.pdf"), width = 8, height=6)
print(km_pam50$plot)
dev.off()
```

Log-rank test for PAM50. Basal generally has a worse than expected outcome, consistent with the literature. 
The others are almost exactly matched with expected.

```{r}
survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ PAM50, data = coxdata)
```

Pairwise log-rank tests demonstrate that no pairing is remotely significant.

```{r}
pairwise_survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ PAM50, data = coxdata)
```

## Immune score

A higher immune score is protective.

```{r}
km_IS = 
survfit(Surv(time=months_overall_survival, event=overall_survival) ~ tertile,
        data = rename(coxdata, tertile = immune_tertile)) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = paste0("Overall survival by immune score (n = ", nrow(coxdata), ")"),
    pval = T,
    palette = "YlOrRd",
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_IS$plot
```

```{r, echo=F, include=F}
pdf(file.path(resDir, "04_km_immune_score.pdf"), width = 8, height=6)
print(km_IS$plot)
dev.off()
```

```{r}
survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ immune_tertile, data = coxdata)
```

## Stromal score

The stromal score does not behave linearly.
The second tertile has a poorer outcome than the first or third.

```{r}
km_SS = 
survfit(Surv(time=months_overall_survival, event=overall_survival) ~ tertile,
        data = rename(coxdata, tertile = stromal_tertile)) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = paste0("Overall survival by stromal score (n = ", nrow(coxdata), ")"),
    pval = T,
    palette = "YlOrRd",
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_SS$plot
```

```{r, echo=F, include=F}
pdf(file.path(resDir, "04_km_stromal_score.pdf"), width = 8, height=6)
print(km_SS$plot)
dev.off()
```

```{r}
survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ stromal_tertile, data = coxdata)
```

## Time in involution

Distribution of groups:

```{r}
table(inv_cox$involution)
```


```{r, fig.width=8, fig.height=6}
km_time_inv = 
survfit(Surv(time=months_overall_survival, event=overall_survival) ~ involution,
        data = inv_cox) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = paste0("Overall survival by time since weaning (n = ", nrow(inv_cox), ")"),
    pval = T,
    palette = viridis::plasma(length(unique(inv_cox$involution))),
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_time_inv$plot

```

Looks like less than 2 months is substantially worse than the rest. Refactor.

```{r}
inv_cox = inv_cox %>%
  mutate(involution = case_when(
    months_involution_breastfeeding < 2 ~ "< 2 months",
    months_involution_breastfeeding >= 2 ~ "> 2 months"
    )) %>% 
  mutate(involution = factor(involution,
                             levels = c("< 2 months", "> 2 months")))

km_time_inv = 
survfit(Surv(time=months_overall_survival, event=overall_survival) ~ involution,
        data = inv_cox) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = paste0("Overall survival by time since weaning (n = ", nrow(inv_cox), ")"),
    pval = T,
    palette = viridis::cividis(length(unique(inv_cox$involution))),
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_time_inv$plot
```

```{r, echo=F, include=F}
pdf(file.path(resDir, "04_km_months_inv.pdf"), width = 8, height=6)
print(km_time_inv$plot)
dev.off()
```

```{r}
survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ involution, data = inv_cox)
```

## Breastfeeding duration

Distribution of groups:

```{r}
table(inv_cox$breastfeeding)
```


```{r, fig.width=8, fig.height=6}
km_brf = 
survfit(Surv(time=months_overall_survival, event=overall_survival) ~ breastfeeding,
        data = inv_cox) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Overall survival probability",
    title = paste0("Overall survival by breastfeeding duration (n = ", nrow(inv_cox), ")"),
    pval = T,
    palette = viridis::plasma(length(unique(inv_cox$breastfeeding))),
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_brf$plot

```


```{r, echo=F, include=F}
pdf(file.path(resDir, "04_km_breastfeeding.pdf"), width = 8, height=6)
print(km_brf$plot)
dev.off()
```

```{r}
survdiff(Surv(time=months_overall_survival, event=overall_survival) ~ breastfeeding, data = inv_cox)
```

# Univariate DRS curves

## PPBC

Just like OS, lactation shows the worst prognosis, followed by involution.
The comparison is less significant overall.

```{r, fig.width = 8}
drs_ppbc = survfit(Surv(time=months_to_drs, event=distant_recurrence) ~ PPBC, data = coxdata) %>% 
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "DRS probability",
    title =  paste0("DRS: All samples with adequate data (n = ", nrow(coxdata), ")"),
    #linetype = "strata",
    palette = "Dark2",
    ggtheme = theme_bw(),
    pval = T,
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

drs_ppbc$plot #Avoids printing a blank plot
```

```{r, echo=F, include=F}
resDir = here("results", "survival")
dir.create(resDir, showWarnings = F)

pdf(file.path(resDir, "04_drs_ppbc.pdf"), width = 8, height = 6)
print(drs_ppbc$plot, newpage=F)
dev.off()
```

A comparison between all groups is not significant.

```{r}
survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ PPBC, data = coxdata)
```

Pairwise log-rank tests show that none of the individual pairings are at or near significance.

```{r}
pairwise_survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ PPBC, data = coxdata)
```

## PAM50

PAM50 shows no significant variance by molecular subtype.

```{r}
drs_pam50 = 
survfit(Surv(time=months_to_drs, event=distant_recurrence) ~ PAM50, data = coxdata) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "DRS probability",
    title =  paste0("DRS: All samples with adequate data (n = ", nrow(coxdata), ")"),
    pval = T,
    palette = "Paired",
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

drs_pam50$plot
```

```{r, echo=F, include=F}
pdf(file.path(resDir, "04_drs_pam50.pdf"), width = 8, height=6)
print(drs_pam50$plot)
dev.off()
```

Log-rank test for PAM50 is similar to OS. Basal generally has a worse than expected outcome,the others match approximately with expected.

```{r}
survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ PAM50, data = coxdata)
```

Pairwise log-rank tests demonstrate that no pairing is remotely significant.

```{r}
pairwise_survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ PAM50, data = coxdata)
```

## Immune score

A higher immune score is protective for DRS as well as OS.

```{r}
drs_IS = 
survfit(Surv(time=months_to_drs, event=distant_recurrence) ~ tertile,
        data = rename(coxdata, tertile = immune_tertile)) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "Distant recurrence probability",
    title = paste0("Distant recurrence by immune score (n = ", nrow(coxdata), ")"),
    pval = T,
    palette = "YlOrRd",
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

drs_IS$plot
```

```{r, echo=F, include=F}
pdf(file.path(resDir, "04_drs_immune_score.pdf"), width = 8, height=6)
print(drs_IS$plot)
dev.off()
```

```{r}
survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ immune_tertile, data = coxdata)
```

## Stromal score

As before, stromal score does not behave linearly.
The second tertile has a poorer outcome than the first or third.

```{r}
drs_SS =
survfit(Surv(time=months_to_drs, event=distant_recurrence) ~ tertile,
        data = rename(coxdata, tertile = stromal_tertile)) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "DRS probability",
    title = paste0("Distant recurrence by stromal score (n = ", nrow(coxdata), ")"),
    pval = T,
    palette = "YlOrRd",
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

drs_SS$plot
```

```{r, echo=F, include=F}
pdf(file.path(resDir, "04_drs_stromal_score.pdf"), width = 8, height=6)
print(km_SS$plot)
dev.off()
```

```{r}
survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ stromal_tertile, data = coxdata)
```

## Time in involution

Distribution of groups:

```{r}
table(inv_cox$involution)
```


```{r, fig.width=8, fig.height=6}
km_drs_inv = 
survfit(Surv(time=months_to_drs, event=distant_recurrence) ~ involution,
        data = inv_cox) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "DRS probability",
    title = paste0("DRS by time since weaning (n = ", nrow(inv_cox), ")"),
    pval = T,
    palette = viridis::cividis(length(unique(inv_cox$involution))),
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

km_drs_inv$plot

```

```{r, echo=F, include=F}
pdf(file.path(resDir, "04_drs_months_inv.pdf"), width = 8, height=6)
print(km_drs_inv$plot)
dev.off()
```

```{r}
survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ involution, data = inv_cox)
```

## Breastfeeding duration

Distribution of groups:

```{r}
table(inv_cox$breastfeeding)
```

```{r, fig.width=8, fig.height=6}
drs_brf = 
survfit(Surv(time=months_to_drs, event=distant_recurrence) ~ breastfeeding,
        data = inv_cox) %>%
ggsurvplot(fit = ., 
    xlab = "Months", 
    ylab = "DRS probability",
    title = paste0("DRS by breastfeeding duration (n = ", nrow(inv_cox), ")"),
    pval = T,
    palette = viridis::plasma(length(unique(inv_cox$breastfeeding))),
    ggtheme = theme_bw(),
    risk.table = F,
    cumevents = F, cumcensor = F,
    test.for.trend = F)

drs_brf$plot

```

```{r, echo=F, include=F}
pdf(file.path(resDir, "04_drs_breastfeeding.pdf"), width = 8, height=6)
print(drs_brf$plot)
dev.off()
```

```{r}
survdiff(Surv(time=months_to_drs, event=distant_recurrence) ~ breastfeeding, data = inv_cox)
```

# Multivariate Cox models

```{r}
head(coxdata)
```


```{r}
coxdata$PPBC = factor(coxdata$PPBC, levels = c("nulliparous", "pregnant", "lactating", "involuting"))

clin.cov.cox <- coxph(
  Surv(time=months_overall_survival,
       event=overall_survival) ~ age_at_diagnosis + year_of_diagnosis + grade + stage + surgery + radiotherapy + hormonetherapy + chemotherapy + herceptin + PAM50 + PPBC,
  data = coxdata)
summary(clin.cov.cox)
```
For DRS

```{r}
drs.clin.cov.cox <- coxph(
  Surv(time=months_to_drs,
       event=distant_recurrence) ~ age_at_diagnosis + year_of_diagnosis + grade + stage + surgery + radiotherapy + hormonetherapy + chemotherapy + herceptin + PAM50 + study_group,
  data = coxdata)
summary(drs.clin.cov.cox)
```






# Session info

```{r}
sessionInfo()
```


Write both the coldata and the new dds object

```{r}
write.csv(coldata_purity, file=here("data","metadata", "04_sample_annot_filtered_PAM50_EST.csv"), row.names = F)
saveRDS(dds, file=here("data","Rds","04_dds_PAM50_EST.Rds"))
```


```{r}
save.image(here("reports","04_survival_and_ESTIMATE.RData"))
```
