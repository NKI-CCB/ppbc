---
title: "Differential expression for ppbc"
output: 
  html_notebook:
    toc: yes
    toc_float: yes
---

```{r, include=F}
#library(devtools)
#install_github("jokergoo/ComplexHeatmap")
#install_github("mikelove/DESeq2")
#install_github("azhu513/apeglm")

library(DESeq2)
library(apeglm)
library(here)
library(tidyverse)
library(ggrepel)
library(ComplexHeatmap)
library(openxlsx)
library(scrime)
library(RColorBrewer)
```

# Load and pre-process data

```{r}
dds <- readRDS(file = here("data/Rds/05_dds_PAM50_tumorpurity_batch.Rds"))

gx_annot <- read_tsv(here("data/metadata/01_tx_annot.tsv"))
gx_annot = gx_annot %>% select(ensembl_gene_id = gene_id, gene_name, gene_type, description = gene_description) %>% distinct()
```


## Filtering


Minimum threshold is a cpm of 1 in at least a 3rd of all samples

```{r}

keep <- rowSums(fpm(dds,robust=F) > 1 ) >= ceiling(ncol(dds)/3)
table(keep)

#Hang on to what we discard for later analysis
dds.discarded <-dds[!keep,]

#Keep the rest
dds <- dds[keep,]

```


## Retrieve immune genes

For downstream analyses, we'd like to know which of the differentially expressed genes are immunologically relevant.

An immune gene is defined as follows:

Either immune/immuno/interleukin is part of the gene name and description OR the gene is part of the the ImmPort database. See https://www.innatedb.com/redirect.do?go=resourcesGeneLists

The Immunology Database and Analysis Portal (ImmPort) system was developed under the Bioinformatics Integration Support Contract (BISC) Phase II by the Northrop Grumman Information Technology Health Solutions team for the NIH, NIAID, and DAIT. The principal investigator of the BISC project is Dr. Richard Scheuermann at University of Texas Southwestern Medical Center. The list of immunologically related genes in ImmPort is a collection of ~6,000 human genes, which was formed with the goal of retrieving all genes that have immune system-related functions. This list was generated using automatic searches of EntrezGene and Gene Ontology records using immunology-related keywords. The list was then manually curated by immunology experts examining various literature sources. 

```{r}
immune_gene_list <- read_csv(here("data", "external","gene-sets","InnateDB_genes.csv"))
head(immune_gene_list)
```

## Helper functions

### Cooks distance

```{r}
plot_cooks <- function(dds, colorby="study_group", method="box", outlier.shape=NA, groupwise_threshold=F, returnOutliers=F,...){
  require(tidyverse)
  require(ggrepel)
  require(RColorBrewer)
  
  stopifnot(method %in% c("box", "upperquartile"))
  if (groupwise_threshold == T & method != "upperquartile"){
    stop("Use groupwise threshold with method = upperquartile.")
  }
  if (returnOutliers == T & groupwise_threshold == F){
    stop("Return outliers only works when groupwise_threshold is TRUE.")
  }
  
  #Spare ourselves the nightmare of trying to use dplyr with variable column names
  sampledata <- data.frame(sample = rownames(as.data.frame(colData(dds))),
                           group = as.data.frame(colData(dds))[,colorby],
                           stringsAsFactors = F)

  #Get the Cooks distances
  cooks <- log10(assays(dds)[["cooks"]])

  #Melt into tidy data frame
  cooks_df <- cooks %>% as.data.frame() %>% rownames_to_column("gene_id") %>% gather(key=sample,-gene_id,value="cooks")
  
  #Add study group info
  cooks_df <- cooks_df %>% left_join(., sampledata, by="sample")
  
  #Sort by the color variable so all the colors are plotted together
  cooks_df <- cooks_df %>% arrange(group)
  
  
  #Create a box plot of all cooks distances by samples, including or excluding the outliers depending on outlier.shape
  if (method=="box"){
    graph = cooks_df %>%
      ggplot(aes(x=factor(sample, levels=unique(sample)), y=cooks, color=group)) +
      geom_boxplot(outlier.shape = outlier.shape) +
      theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
      labs(color=colorby) + xlab("sample") +
      scale_colour_brewer(type = "qual", palette = "Set1")
  }
  
  
  #Plot just the upper quartile of the cooks distances as a single point
  #Allows more readable labels
  if (method=="upperquartile"){
    cooksQuartile = cooks_df %>% group_by(sample) %>% summarise(upper_cook = quantile(cooks)[4]) #Get the upper quartile
    cooksQuartile = cooksQuartile %>% left_join(.,sampledata, by="sample")

    #Sort by group to have colors plotted together
    cooksQuartile = cooksQuartile %>% arrange(group)
    
    if (groupwise_threshold==T){
      
      #Set a threshold of two standard deviations above the mean upper quartile for Cook's distance
      cooksThreshold = cooksQuartile %>% group_by(group) %>%
        summarise(meanUC=mean(upper_cook), stdevUC=sd(upper_cook, na.rm=T)) %>% mutate(threshold=meanUC+2*stdevUC)
      
      cooksThreshold = left_join(cooksQuartile,cooksThreshold, by="group")  %>%
        mutate(label = if_else(upper_cook > threshold, sample, NULL)) #Label those samples above the threshold

      #First plot the UQ cooks distance by color group
      graph = cooksThreshold %>% ggplot(aes(x=factor(sample, level=unique(sample)), y = upper_cook, color=group, label=label)) +
        geom_point() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
        labs(color=colorby, title="Labelled samples exceed groupwise Cooks threshold of 2sd + mean(UQ)") + xlab("sample") +
        scale_colour_brewer(type = "qual", palette = "Set1")
      
      #Add labels for samples above the threshold
      graph = graph + ggrepel::geom_label_repel(size=4, show.legend = F)
      
      #store the outliers as a vector
      outliers = cooksThreshold %>% filter(!is.na(label)) %>% select(sample, group)

    } else {

      #Produce a graph of upper quartiles cooks distance with no samples labeled
      graph = cooksQuartile %>% ggplot(aes(x=factor(sample, level=unique(sample)), y = upper_cook,color=group)) +
        geom_point() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
        labs(color=colorby) + xlab("sample") +
        scale_colour_brewer(type = "qual", palette = "Set1")
    }
  }
  if (returnOutliers == T){
    return(outliers)
  } else {
    return(graph)
  }
}
```

### Annotate results 
```{r}
annotate_results <- function(results_object, anno_df = gx_annot, mark_immune = T, immune_list = immune_gene_list){
  require(tidyverse)
  
  anno_res <- results_object %>% as.data.frame() %>% rownames_to_column("ensembl_gene_id") %>%
    right_join(anno_df,., by = "ensembl_gene_id") %>% arrange(padj)
  
  if (mark_immune==T){
    anno_res = anno_res %>% mutate(immune_gene = if_else(
      ensembl_gene_id %in% immune_list$ensembl |
        str_detect(string = description, "immuno") |
        str_detect(string = description, "immune") |
        str_detect(string = description, "interleukin"),
      TRUE, FALSE
    )) %>% #When description is NA, immune_gene is also NA
      mutate(immune_gene = replace_na(immune_gene, FALSE))
  }
  
  return(anno_res)
}
```

### Significant gene threshold

```{r}
significance <- function(annotated_results, pthresh = 0.05, absl2fc = 1){
  require(tidyverse)
  sig = annotated_results %>% filter(padj < !!pthresh & (abs(log2FoldChange) > !!absl2fc))
  return(sig)
}
```

### Volcano plot
```{r}
volcano_plot <- function(annotated_results, title, path_save_fig = NULL, pthresh = 0.05, absl2fc=1, shape_col=NULL){
  
  require(tidyverse)
  require(ggrepel)
  require(here)
  
  volcdf <- annotated_results %>% mutate(NegLog10FDR = -log10(padj),
                   Significant = if_else(
                     (padj < !!pthresh & abs(log2FoldChange) > !!absl2fc),
                     TRUE, FALSE),
                   Type=case_when(
                     gene_type == "protein_coding" ~ "protein coding",
                     str_detect(string=gene_type,pattern="IG") ~ "IG gene",
                     TRUE ~ "other noncoding"),
                   Color = if_else(
                     Significant == T, Type, "n.s."
                   )) %>% 
  filter(!is.na(Significant))
  
  colors = c(`IG gene` = "red", `n.s.` = "gray",`other noncoding`="purple",`protein coding`="darkgreen")

  volcplot <-ggplot(volcdf, aes(x=log2FoldChange,y=NegLog10FDR, color=Color)) +
    geom_point() +
    scale_color_manual(values=colors) +
    geom_hline(yintercept = -log10(pthresh), colour="darkred", linetype="dashed") + 
    geom_vline(xintercept = absl2fc, color="darkred", linetype="dashed") +
    geom_vline(xintercept = -absl2fc, color="darkred", linetype="dashed") +
    theme_bw()
  
  volcplot <-
    volcplot + 
    geom_text_repel(data=head(volcdf[volcdf$Significant==T,], 10), aes(label=gene_name), show.legend = F) +
    ggtitle(title) +
    labs(y="-log10(FDR)")
  
  if (is.null(path_save_fig)==F){
    suppressMessages(ggsave(filename=path_save_fig, plot = volcplot))
    }

  if (is.null(shape_col)==F){
    volcplot = volcplot + aes(shape=get(shape_col)) + labs(shape=shape_col)
    }

  return(volcplot)

}
```

### Complex heatmap

```{r}

complex_heatmap <- function(vsd, annotated_results, groups_to_plot=levels(vsd$study_group),
                            row_annot=F, row_scale = FALSE, row_id = "gene_name",
                            row_size = 8, col_size = 8, ...){
  
  require(DESeq2)
  require(ComplexHeatmap)
  require(tidyverse)
  require(scrime)
  require(RColorBrewer)
  
  stopifnot(row_id %in% c("gene_name", "ensembl_gene_id", "concatenate"))
  stopifnot(groups_to_plot %in% levels(vsd$study_group))
  
  genes_to_plot = annotated_results[,c("ensembl_gene_id", "gene_name")]
  samples_to_plot = colnames(vsd)[as.data.frame(colData(vsd)["study_group"])[,1] %in% groups_to_plot]
  
  vsd = vsd[genes_to_plot$ensembl_gene_id, samples_to_plot]
  
  mat = assay(vsd)
  
  if (row_scale==T){
    mat = scrime::rowScales(mat)
  }
  
  title = if_else(groups_to_plot == levels(vsd$study_group),
                  "All groups",
                  paste(groups_to_plot, collapse="vs"))
  
  stopifnot(identical(rownames(mat), genes_to_plot$ensembl_gene_id))
  
  if (row_id == "gene_name"){
    row_labels = genes_to_plot$gene_name
  } else if (row_id == "concatenate"){
    row_labels = paste(genes_to_plot$gene_name, genes_to_plot$ensembl_gene_id, ":")
  } else {
    row_labels = rownames(mat)
  }
  
  # Top column annotation
  ann_top = as.data.frame(colData(vsd)["study_group"])
  
  #Colors must be named lists with named elements
  study_colors=suppressWarnings(colorRampPalette(brewer.pal(length(unique(vsd$study_group)),"Spectral"))(length(unique(vsd$study_group))))
  names(study_colors) = unique(vsd$study_group)
  
  top_cols=list(study_group=study_colors)
  
  colTop <- HeatmapAnnotation(df=ann_top, which="col", col = top_cols)
  
  #Bottom column annotation
  ann_bottom = as.data.frame(colData(vsd)["PAM50"])
  pam_colors = suppressWarnings(colorRampPalette(brewer.pal(length(unique(vsd$PAM50)),"Paired"))(length(unique(vsd$PAM50))))
  names(pam_colors)= unique(vsd$PAM50)
  bottom_cols = list(PAM50 = pam_colors)
  colBottom <- HeatmapAnnotation(df=ann_bottom, which="col", col = bottom_cols)
  
  # Row annotation - not working in current version?
  anno_rows = tibble(ensembl_gene_id = annotated_results$ensembl_gene_id, gene_type=annotated_results$gene_type) %>% 
    mutate(Type=case_when(gene_type == "protein_coding" ~ "protein coding",
                     str_detect(string=gene_type,pattern="IG") ~ "IG gene",
                     TRUE ~ "other noncoding")) %>%
    column_to_rownames("ensembl_gene_id") %>% select(Type)
  
  type_colors = suppressWarnings(colorRampPalette(brewer.pal(length(unique(anno_rows$Type)),"Set1"))(length(unique(anno_rows$Type))))
  names(type_colors) = unique(anno_rows$Type)
  row_colors = list(Type = type_colors)
  
  rowAnno = HeatmapAnnotation(df=anno_rows, which="row", col=row_colors)
  
  
  if (row_scale==T){
   hlp = list(title="rowscaled vst") 
  } else {
    hlp = list(title="vst counts")
  }
  
  Heatmap(mat, top_annotation = colTop, bottom_annotation = colBottom, left_annotation = rowAnno,
          heatmap_legend_param = hlp, row_labels = row_labels, #column_title=title, #Column title causes errors in wrapper
          row_names_gp = gpar(fontsize = row_size), column_names_gp = gpar(fontsize = col_size), ...)
}



```

### Plot beehive

```{r}
plot_gene_beehive = function(dds, result_df, groups_to_plot = levels(colData(dds)[,intgroup]),
                             intgroup="study_group", colorby="PAM50", path_save_fig = NULL){
  
  require(DESeq2)
  require(tidyverse)
  
  if(nrow(result_df) > 1){
    warning("More than one result provided, plotting first row")
    result_df = head(result_df, 1)
  }
  
  ensembl_gene_id = result_df$ensembl_gene_id
  gene_name = result_df$gene_name
  
  stopifnot(groups_to_plot %in% levels(colData(dds)[,intgroup]))
  
  comparison = if_else(groups_to_plot == levels(colData(dds)[,intgroup]),
                       "all groups", paste(groups_to_plot, collapse = " vs "))
  
  
  samples_to_keep = colnames(dds)[as.data.frame(colData(dds)[intgroup])[,1] %in% groups_to_plot]
  
  dds.trim = dds[,samples_to_keep]
  
  #Normalizes by size factors
  d <- plotCounts(dds.trim, gene=ensembl_gene_id, intgroup=c(intgroup,colorby), normalize=T, returnData=TRUE)
  
  title = paste0(paste(gene_name,ensembl_gene_id, sep=":"), ", ", comparison, ", padj: ",
                 formatC(result_df$padj, format = "e", digits = 2),
                 ", log2fc: ", round(result_df$log2FoldChange,2))
  
  dplot = ggplot(d, aes(x=get(intgroup), y=count)) + 
    geom_boxplot(alpha=0, show.legend = F, outlier.shape = NA) +
    geom_point(position=position_jitter(w=0.1,h=0), aes(color=get(colorby))) + 
    scale_y_log10() + xlab(intgroup) + labs(color=colorby) + ylab("size-factor normalized counts") +
    ggtitle(title)
  
  if (is.null(path_save_fig)!=T){
    suppressMessages(ggsave(filename=path_save_fig, plot = volcplot))
  }
  
  return(dplot)
}
```

### Plot multiple beehives

```{r}
plot_many_beehives = function(dds, result_df, ...){
  plotlist = list()
  for (i in 1 : nrow(result_df)){
    plotlist[[length(plotlist)+1]]= plot_gene_beehive(dds, result_df = result_df[i,], ...)
  }
  return(plotlist)
}
```

### Report wrapper function

```{r}
deseq_report = function(results_object, dds, anno_df = gx_annot, mark_immune=T, immune_list=immune_gene_list,
                        pthresh = 0.05, absl2fc = 1, variance_stabilized_dds = vsd,
                        intgroup="study_group", colorby="PAM50", shape_volc_col = "immune_gene",
                        groups=levels(colData(dds)[,intgroup]),
                        n_beehive_plots=5, verbose=F, ...){
  require(DESeq2)
  require(tidyverse)
  
  mega = list()
  
  #Merge deseq results object with gene name and type annotation
  if(verbose==T){
    print("Annotating results...")
  }
  
  df = annotate_results(results_object, mark_immune = mark_immune, immune_list = immune_list)
  
  mega$annotated_results = df
  
  #Set significance threshold and save significant hits
  print(paste("Significance threshold is padj:", pthresh, "and abs(log2foldchange):", absl2fc))
  
  mega$sig_threshold = list(padj = pthresh, absl2fc = absl2fc)
  
  sig = significance(df, pthresh = pthresh, absl2fc = absl2fc)
  
  print(paste("Number of significant genes:", nrow(sig)))
  
  mega$significant_genes = sig
    
  #Draw volcano plot
  if(verbose==T){
    print("Creating volcano plot...")
  }
  
  title = if_else(groups==levels(colData(dds)[,intgroup]), "All groups - Interpret with caution",
                  paste(groups, collapse=" vs "))
  
  vp = volcano_plot(annotated_results = df, title=title, pthresh = pthresh, absl2fc = absl2fc, shape_col = shape_volc_col)
  
  mega$volcano_plot = vp
  
  #Draw heatmap
  if(verbose==T){
    print("Creating heatmap...")
  }
  
  hm = complex_heatmap(vsd = variance_stabilized_dds, annotated_results = sig, groups_to_plot=groups, row_scale = T,
                      show_column_names=F, show_row_names=F)
  
  mega$heatmap = hm
  
  #Draw a selection of beehive plots from top hits
  if(verbose==T){
    print(paste("Creating beehive plots from top", n_beehive_plots, "genes..."))
  }
  beelist = plot_many_beehives(dds = dds, result_df = head(sig, n_beehive_plots), groups_to_plot = groups)
  
  mega$beehive_plots = beelist
  
  return(mega)

}
```

### Extract results and shrink log2fold changes

```{r}
shrinkRes <- function(dds, contrast, type="apeglm"){
  require(DESeq2)
  require(tidyverse)
  
  cdf = enframe(colnames(coef(dds)), "coef", "name")
  contrast_name = paste(contrast[1], contrast[2], "vs",contrast[3], sep="_")
  
  if(!contrast_name %in% cdf$name){
    stop("Contrast name not found within coefficients. Do you need to relevel your design formula?")
  }
  
  print("Detecting coefficient corresponding to contrast:")

  c = cdf[cdf$name==contrast_name,]
  print(paste("Contrast name:", c$name))
  print(paste("Coefficient:", c$coef))
  
  print("Retrieving results from deseq dataset with contrast...")
  res = results(dds, contrast=contrast)

  print(paste("Shrinking log2foldchanges via method", type))
  ape <- lfcShrink(dds, coef = c$coef, res = res, type="apeglm")
  
  return(ape)
}
```

## Variance stabilizing transformation

We want a transformation that is fully blind to the experimental design, but still uses the faster sampling method in the vst wrapper for varianceStabilizingTransformation.

This homoskedastic dataset will be used later on for heatmap visualization.

```{r}
blind_vst = function(dds){
  design(dds) = formula(~ 1)
  vsd = vst(dds, blind=T)
  #mat = assay(vsd)
  return(vsd)
}
```

```{r}
vsd = blind_vst(dds)
```


# Likelihood ratio test

The likelihood ratio test (LRT) is an ANOVA-like test design to check for genes which are significantly differentially expressed in at least one group. From the manual: "The LRT examines two models for the counts, a full model with a certain number of terms and a reduced model, in which some of the terms of the full model are removed. The test determines if the increased likelihood of the data using the extra terms in the full model is more than expected if those extra terms are truly zero."

Our design formula is as follows:

```{r}
design(dds)
```

We will test it versus a formula that lacks the study group for genes of interest.

```{r}
start <- Sys.time()
ddsLRT = DESeq(dds, test="LRT", reduced= ~ batch + PAM50 + tumor_purity)
end <- Sys.time()
end-start
```

Using the apeglm package doesn't make sense because log fold changes are less meaningful in a 4way comparison.

```{r}
resLRT <- results(ddsLRT)
```

```{r}
saveRDS(ddsLRT, here("data/Rds/06c_ddsLRT_apeglm_1cpm.Rds"))
```


# LRT report

## Summary

```{r}
repLRT = deseq_report(resLRT, dds=ddsLRT, absl2fc = 0.5)
```

## Top genes

```{r}
repLRT$significant_genes %>% head(30)
```


## Heatmap

```{r}
draw(repLRT$heatmap, column_title = "Likelihood ratio test")
```

To invoke separately:
complex_heatmap(vsd, annotated_results = significance(dfLRT),
                  row_dend_reorder = TRUE, row_scale = T, show_row_names=F, show_column_names=F)



## Box plots

Plot the top 5 most significant.

```{r}
repLRT$beehive_plots
```


# Diffex: non-prbc as reference groups

In this call to DESeq, we're focusing in group-by-group contrasts and using a Wald test instead of a likelihood ratio test.

Ensure that non-prbc is the reference level

```{r}
dds$study_group = relevel(dds$study_group, ref="non_prbc")

levels(dds$study_group)
```

Perform differential expression analysis.

```{r}
start = Sys.time()
dds <- DESeq(dds)
end = Sys.time()
end-start
```


```{r}
#dds=readRDS(here("data/Rds/06c_dds_apeglm_1cpm.Rds"))
saveRDS(dds,here("data/Rds/06c_dds_apeglm_1cpm_nonprbcref.Rds"))
```



## Coefficient overview

Make it easier to find the coefficient we need.

```{r}
cdf = enframe(colnames(coef(dds)), "coef", "name")

cdf
```


# Involution vs non-prbc

## Extract results

```{r}
ape_inv_nonprbc = shrinkRes(dds,  contrast=c("study_group", "ppbc_inv", "non_prbc"))
```

## Summary report


```{r}
rep_inv_nonprbc = deseq_report(ape_inv_nonprbc, dds=dds, absl2fc = 0.5, groups = c("ppbc_inv", "non_prbc"))
```

## Top genes

```{r}
rep_inv_nonprbc$significant_genes %>% head(30)
```

## Volcano plot


```{r}
rep_inv_nonprbc$volcano_plot
```

## Heatmap

```{r}
draw(rep_inv_nonprbc$heatmap, column_title = "Involution vs non-prbc")
```


## Beehive plots

Beehive plot of top 5 most significantly expressed genes.

```{r}
rep_inv_nonprbc$beehive_plots
```




# Pregnancy vs non-pregnancy

## Extract results

```{r}
ape_prbc_nonprbc = shrinkRes(dds,  contrast=c("study_group", "prbc", "non_prbc"))
```

## Summary report

```{r}
rep_prbc_nonprbc = deseq_report(ape_prbc_nonprbc, dds=dds, absl2fc = 0.5, groups = c("prbc", "non_prbc"))
```

## Top genes

```{r}
rep_prbc_nonprbc$significant_genes %>% head(30)
```

## Volcano plot

```{r}
rep_prbc_nonprbc$volcano_plot
```

## Heatmap

```{r}
draw(rep_prbc_nonprbc$heatmap, column_title = "Prbc vs non-prbc")
```


## Beehive plots

Beehive plot of top 5 most significantly expressed genes.

```{r}
rep_prbc_nonprbc$beehive_plots
```


# Lac vs non-prbc

## Extract results

```{r}
ape_lac_nonprbc = shrinkRes(dds,  contrast=c("study_group", "ppbc_lac", "non_prbc"))
```

## Summary report

```{r}
rep_lac_nonprbc = deseq_report(ape_lac_nonprbc, dds=dds, absl2fc = 0.5, groups = c("ppbc_lac", "non_prbc"))
```

## Top genes

```{r}
rep_lac_nonprbc$significant_genes %>% head(30)
```

## Volcano plot

```{r}
rep_lac_nonprbc$volcano_plot
```

## Heatmap

```{r}
draw(rep_lac_nonprbc$heatmap, column_title = "Lac vs non-prbc")
```


## Beehive plots

Beehive plot of top 5 most significantly expressed genes.

```{r}
rep_lac_nonprbc$beehive_plots
```

# Diffex: prbc as reference level

From the manual: 

Although apeglm cannot be used with contrast, we note that many designs can be easily rearranged such that what was a contrast becomes its own coefficient. In this case, the dispersion does not have to be estimated again, as the designs are equivalent, up to the meaning of the coefficients. Instead, one need only run nbinomWaldTest to re-estimate MLE coefficients – these are necessary for apeglm – and then run lfcShrink specifying the coefficient of interest in resultsNames(dds). We give some examples below of producing equivalent designs for use with coef. We show how the coefficients change with model.matrix, but the user would, for example, either change the levels of dds$condition or replace the design using design(dds)<-, then run nbinomWaldTest followed by lfcShrink.

```{r}
dds$study_group = relevel(dds$study_group, ref="prbc")
levels(dds$study_group)
```

```{r}
start = Sys.time()
dds = nbinomWaldTest(dds)
end = Sys.time()
end - start
```

```{r}
saveRDS(dds,here("data/Rds/06c_dds_apeglm_1cpm_prbcref.Rds"))
```


## Coefficient summary

```{r}
resultsNames(dds)
```

# Involution vs prbc

## Extract results

```{r}
ape_inv_prbc = shrinkRes(dds,  contrast=c("study_group", "ppbc_inv", "prbc"))
```

## Summary report

```{r}
rep_inv_prbc = deseq_report(ape_inv_prbc, dds=dds, absl2fc = 0.5, groups = c("ppbc_inv", "prbc"))
```

## Top genes

```{r}
rep_inv_prbc$significant_genes %>% head(30)
```

## Volcano plot

```{r}
rep_inv_prbc$volcano_plot
```

## Heatmap

```{r}
draw(rep_inv_prbc$heatmap, column_title = "Involution vs prbc")
```

## Beehive plots

Beehive plot of top 5 most significantly expressed genes.

```{r}
rep_inv_prbc$beehive_plots
```


# Lac vs prbc

## Extract results

```{r}
ape_lac_prbc = shrinkRes(dds,  contrast=c("study_group", "ppbc_lac", "prbc"))
```

## Summary report

```{r}
rep_lac_prbc = deseq_report(ape_lac_prbc, dds=dds, absl2fc = 0.5, groups = c("ppbc_lac", "prbc"))
```

## Top genes

```{r}
rep_lac_prbc$significant_genes %>% head(30)
```

## Volcano plot

```{r}
rep_lac_prbc$volcano_plot
```

## Heatmap

```{r}
draw(rep_lac_prbc$heatmap, column_title = "Lactation vs prbc")
```

## Beehive plots

Beehive plot of top 5 most significantly expressed genes.

```{r}
rep_lac_prbc$beehive_plots
```

# Diffex: Lac as reference level

We have only one comparison remaining: involution vs lac. For this we need to set lactation as the reference group.

```{r}
dds$study_group = relevel(dds$study_group, ref="ppbc_lac")
levels(dds$study_group)
```

```{r}
start = Sys.time()
dds = nbinomWaldTest(dds)
end = Sys.time()
end - start
```

```{r}
saveRDS(dds,here("data/Rds/06c_dds_apeglm_1cpm_lacref.Rds"))
```

## Coefficient summary

```{r}
resultsNames(dds)
```

# Involution vs lac

## Extract results

```{r}
ape_inv_lac = shrinkRes(dds, contrast=c("study_group", "ppbc_inv", "ppbc_lac"))
```

## Summary report

```{r}
rep_inv_lac = deseq_report(ape_inv_lac, dds=dds, absl2fc = 0.5, groups = c("ppbc_inv", "ppbc_lac"))
```

## Top genes

```{r}
rep_inv_lac$significant_genes %>% head(30)
```

## Volcano plot

```{r}
rep_inv_lac$volcano_plot
```

## Heatmap

```{r}
draw(rep_inv_lac$heatmap, column_title = "Involution vs lactation")
```

## Beehive plots

Beehive plot of top 5 most significantly expressed genes.

```{r}
rep_inv_lac$beehive_plots
```

# Save data

```{r}
save.image(here("reports/06c_diffex_apeglm_highercountthreshold.Rdata"))
```

