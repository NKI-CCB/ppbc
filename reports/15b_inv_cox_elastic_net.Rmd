---
title: "Cox elastic net models, involution samples only"
author: "Kat Moore"
date: "`r Sys.Date()`"
output: 
   html_document:
    toc: yes
    toc_float: yes
    toc_depth: 4
    highlight: tango
    df_print: paged
---

As report 15, but with involution samples only.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(here)
library(DESeq2)
library(survival)
library(pheatmap)
library(glmnet)
library(ggpubr)
library(UpSetR)
library(ggrepel)
library(tidyverse)
theme_set(theme_bw())
```

# Load data {.tabset}

A samples x features matrix, where features contain both clinical covariates and log2-transformed, TMM-normalized gene expression data.

```{r}
coxdata = readRDS(here("data/Rds/12_invdata.Rds"))
#head(coxdata[,1:30])
genecol = which(colnames(coxdata)=="ENSG00000000003")
metacol = 4
```

First `r metacol` columns are metadata:

```{r}
head(coxdata[,1:metacol])
```

Clinical covariates and survival/metastasis endpoints are columns 5 through `r genecol-1`.

```{r}
head(coxdata[,(metacol + 1):(genecol-1)])
```

Create separate data frames for metadata and covariates.

```{r}
metadata <- coxdata %>%
  select(sample_name:PPBC,
         months_of_followup,
         overall_survival,
         months_overall_survival,
         metastasis_at_diagnosis,
         distant_recurrence,
         months_to_drs)
colnames(metadata)

covdf <- coxdata[,1:(genecol-1)]
covdf <- covdf[,!colnames(covdf) %in% colnames(metadata)]
colnames(covdf)
```

Columns `r genecol-1` through `r ncol(coxdata)` are gene expression.

```{r}
geneEx = coxdata[,genecol:ncol(coxdata)]
head(geneEx[,1:4])
```

## Gene sets and annotation

Gene annotation:

```{r}
gx_annot <- read_tsv(here("data/metadata/01_tx_annot.tsv"))
gx_annot = gx_annot %>% select(ensembl_gene_id = gene_id, gene_name,
                               gene_type, description = gene_description) %>% distinct()
```

Gene signatures for Fisher's exact tests

```{r}
source(here("src/enrichment-analysis-functions.R"))
```

```{r}
gene_sets = list(
  go_bp = flexgsea::read_gmt(here("data","external","gmt","c5.bp.v7.0.symbols.gmt")),
  hallmark = flexgsea::read_gmt(here("data","external","gmt","h.all.v7.0.symbols.gmt")),
  c2_canon = flexgsea::read_gmt(here("data","external","gmt","c2.cp.v7.0.symbols.gmt")),
  c2_cgp = flexgsea::read_gmt(here("data","external","gmt","c2.cgp.v7.0.symbols.gmt"))
)
```

## Colors

```{r}
cp = readRDS(here("data", "Rds", "color_palettes.Rds"))
study_colors = cp$study_colors
pam_colors = cp$pam_colors
gene_colors = cp$gene_colors
ppbc_colors = cp$ppbc_colors

sp = readRDS(here("data/Rds/survival_colors.Rds"))
```

## Gene symbol matrix

Convert IDs to symbols and average duplicates.

```{r}
source(here("src", "general_R_tools.R"))
geneSym = rownames_to_column(as.data.frame(t(geneEx)), "ensembl_gene_id")
geneSym = right_join(select(gx_annot, gene_name, ensembl_gene_id),
                    geneSym, by = "ensembl_gene_id") %>%
  select(-ensembl_gene_id)
geneSym = summarize_expression_duplicate_ids(geneSym, id_column = "gene_name")
rownames(geneSym) = NULL
geneSym <- column_to_rownames(geneSym, "GeneSymbol")
geneSym[1:4,1:4]
```

## Diffex results

```{r}

lrt <- list(readxl::read_excel(here("results", "diffex", "06_LRT_allgenes.xlsx"),
                          sheet = "repLRT_all"))
names(lrt) <- "LRT"

pw <- 
here("results", "diffex", "07_pairwise_comparisons_allgenes.xlsx") %>% 
  readxl::excel_sheets() %>% 
  purrr::set_names() %>% 
  purrr::map(readxl::read_excel, path = here("results", "diffex", "07_pairwise_comparisons_allgenes.xlsx"))
#names(pw)

ovr = here("results", "diffex", "08_one_vs_rest_allgenes.xlsx") %>% 
  readxl::excel_sheets() %>% 
  purrr::set_names() %>% 
  purrr::map(readxl::read_excel, path = here("results", "diffex", "08_one_vs_rest_allgenes.xlsx"))
#names(ovr)

diffex_list = append(pw, ovr)
diffex_list = append(diffex_list, lrt)
names(diffex_list) = str_remove_all(str_remove_all(names(diffex_list), "rep_"), "_all")
names(diffex_list) = str_replace(names(diffex_list), "_", "_vs_")
#names(res_list)

#diffex_list = bind_rows(diffex_list, .id="comparison")

basemeans = ovr$rep_inv_rest_all %>%
  select(ensembl_gene_id, baseMean, type=Type) %>%
  arrange(ensembl_gene_id) %>% distinct() %>%
  mutate(baseMean = round(baseMean, 2))

stopifnot(nrow(filter(basemeans, duplicated(ensembl_gene_id))$ensembl_gene_id)==0)

names(diffex_list)

```

## Previous survival results

Genewise models:

```{r}
genewise_cox = c(
  "multi_genewise_os", "uni_genewise_os",
  "multi_genewise_drs", "uni_genewise_drs",
  "inv_multi_genewise_os", "inv_uni_genewise_os",
  "inv_multi_genewise_drs", "inv_uni_genewise_drs"
)

gw_surv=lapply(here(paste0("results/survival/12_", genewise_cox,".csv")), read.csv)
names(gw_surv) = genewise_cox
gw_surv[[1]] %>% head()
```

Interaction results:

```{r}
int_cox = c(
  "multi_interaction_os",
  "multi_interaction_drs"
)

int_surv=lapply(here(paste0("results/survival/13_", int_cox,".csv")), read.csv)
names(int_surv) = int_cox
int_surv[[1]] %>% head()
```


# Variant gene extaction {.tabset}

The input of the elastic net models will be either the top 1000 or the top 5000 most variant genes.

## Top 1000

Extract 1000 most variable genes

```{r}
top1000var = head(sort(apply(geneEx, 2, var), decreasing = T), 1000)
top1000var %>% head()
top1000var = names(top1000var)
```

Transform and combine with survival

```{r}
var1000 = data.matrix(cbind(covdf, geneEx[,colnames(geneEx) %in% top1000var]))
stopifnot(all(rowSums(is.na(var1000)) == 0))
var1000[1:4, 1:15]
```

## Top 5000

Extract 5000 most variable genes

```{r}
top5000var = head(sort(apply(geneEx, 2, var), decreasing = T), 5000)
top5000var %>% head()
top5000var = names(top5000var)
```

Transform and combine with survival

```{r}
var5000 = data.matrix(cbind(covdf, geneEx[,colnames(geneEx) %in% top5000var]))
stopifnot(all(rowSums(is.na(var5000)) == 0))
var5000[1:4, 1:15]
```

# OS/DRS Time Points

For family="cox", y should be a two-column matrix with columns named 'time' and 'status'. 
The latter is a binary variable, with '1' indicating death, and '0' indicating right censored.  

Overall survival:

```{r}
time_os = data.frame(time = metadata$months_overall_survival,
                     event = metadata$overall_survival)
rownames(time_os) = metadata$sample_name

#os = as.matrix(os)
time_os = Surv(time_os$time, time_os$event)
head(time_os)
```

Metastasis
When looking at drs, time point 0 (metastatic at diagnosis) is not allowed

```{r}
met_at_diag <- metadata %>%
  filter(metastasis_at_diagnosis == 1) %>%
  pull(sample_name)

met_at_diag
```

```{r}
time_drs = data.frame(time = coxdata$months_to_drs, event = coxdata$distant_recurrence)
rownames(time_drs) = coxdata$sample_name
time_drs = time_drs[!rownames(time_drs) %in% met_at_diag,]

time_drs = time_drs[time_drs$time!=0,]
#drs = as.matrix(drs)
time_drs = Surv(time_drs$time, time_drs$event)
head(time_drs)

var1000.drs = var1000[!(rownames(var1000) %in% met_at_diag),]
var5000.drs = var5000[!(rownames(var5000) %in% met_at_diag),]
```

# Run Cox elastic net models {.tabset}

A pentalized cox model to determine which groups of covariates are most predictive of survival.
Using nested crossvalidation.

```{r}
nested.cox <- function(x,y,nfolds=10,nfolds_inner=10,
                       n_preds = 5,
                       print_time = T,
                       s="lambda.min",
                       alpha=0.5){
  #Based on nested.cv from the TANDEM package
  start <- Sys.time()
  samples = rownames(x)
  n = length(y)
  foldid = ceiling(sample(1:n)/n * nfolds)
  
  fitted_relative_risk = rep(NA, length(y))
  risklist <- list()
  features = list()
  pred = list()
  fits = list()
  
  for (n in 1:n_preds){
    
    for (i in 1:nfolds) {
          
        ind = foldid == i
        x_train = x[!ind, ]
        y_train = y[!ind]
        x_test = x[ind, ]
        n_i = length(y_train)
        foldid_i = ceiling(sample(1:n_i)/n_i * nfolds_inner)
        fit = glmnet::cv.glmnet(x_train, y_train, family = "cox", alpha = alpha,
                                foldid = foldid_i)
        fits[[length(fits) + 1]] = fit
      
        features[[length(features) + 1]] = coef(fit, s=s)[,1] %>% enframe() %>% filter(value!=0 & name != "(Intercept)")
        fitted_relative_risk[ind] = glmnet::predict.cv.glmnet(fit, 
                newx = x_test, s = s, alpha=alpha, type="response")

    }
    
    relrisk <- tibble(samples = samples, fitted_relative_risk = fitted_relative_risk)
    risklist[[length(risklist)+1]] <- relrisk
    #pred[[length(pred)+1]] <- list(features = features, relrisk = relrisk, fits = fits)
    pred$features <- features
    pred$relrisk <- risklist
    pred$fits <- fits
    print(n)

  }

  end <- Sys.time()
  if (print_time){print(end-start)}
  return(pred)
}


```

These models were run in script 15b.

```{r}
resDir <- here("data", "Rds")

glm.os1000 <- readRDS(file.path(resDir,"15b_inv_glm_os_1000.Rds"))

glm.os5000 <- readRDS(file.path(resDir,"15b_inv_glm_os_5000.Rds"))

glm.drs1000 <- readRDS(file.path(resDir,"15b_inv_glm_drs_1000.Rds"))

glm.drs5000 <- readRDS(file.path(resDir,"15b_inv_glm_drs_5000.Rds"))


glm_list <- list(
  os1000=list(model=glm.os1000,
              title="Overal survival, top 1000"),
  os5000=list(model=glm.os5000,
              title="Overal survival, top 5000"),
  drs1000=list(model=glm.drs1000,
               title="Distant recurrence, top 1000"),
  drs5000=list(model=glm.drs5000,
               title="Distant recurrence, top 5000")
)
```


# Model fit plots {.tabset}

## Overall survival

Top 1000 most variable genes:

```{r, fig.width=8, fig.height=10}
par(mar=c(4,4,2,2))
par(mfrow=c(5,2))
lapply(glm.os1000$fits[1:10], plot)
```

Top 5000 most variable genes:

```{r, fig.width=8, fig.height=10}
par(mar=c(4,4,2,2))
par(mfrow=c(5,2))
lapply(glm.os5000$fits[1:10], plot)
```

Zoom in on a sample plot with less than 100 features selected. Requires rerunning glmnet, so we'll do it only once.

This shows that at least some performance is gained in lambda.min vs a model with minimal features.

```{r}
set.seed(123)

glm.os.zoom = cv.glmnet(x = var1000, y = time_os, family = "cox", alpha = 0.5, df=100)
plot(glm.os.zoom)
```

## Distant recurrence

Top 1000 most variable genes:

```{r, fig.width=8, fig.height=10}
par(mar=c(4,4,2,2))
par(mfrow=c(5,2))
lapply(glm.drs1000$fits[1:10], plot)
```

Top 5000 most variable genes:

```{r, fig.width=8, fig.height=10}
par(mar=c(4,4,2,2))
par(mfrow=c(5,2))
lapply(glm.drs5000$fits[1:10], plot)
```

# Features {.tabset}

Number of features selected over 10 xval loops, out of 50 total models.

For Cox elastic net models predicting:

* Overall survival
* Distant recurrence

With either

* Top 1000 var
* Top 5000 var

Genes inputed as features,
a minimum of `{r} round(mean(unlist(lapply(glm_list, function(x) min(sapply(x$model$features, nrow))))),2)` features are selected as predictive.

On average, `{r} round(mean(unlist(lapply(glm_list, function(x) mean(sapply(x$model$features, nrow))))),2)` features are selected.

The standard deviation is `{r} round(mean(unlist(lapply(glm_list, function(x) sd(sapply(x$model$features, nrow))))),2)`

```{r, include=T}
tibble(
  model = names(glm_list),
  outcome = c("survival", "survival", "metastasis", "metastasis"),
  input_var_genes = c(1000, 5000, 1000, 5000),
  min_feat=unlist(lapply(glm_list, function(x) min(sapply(x$model$features, nrow)))),
  med_feat=unlist(lapply(glm_list, function(x) median(sapply(x$model$features, nrow)))),
  sd_feat=unlist(lapply(glm_list, function(x) sd(sapply(x$model$features, nrow))))
  )

```

Histogram of feature slection frequency

```{r}
par(mfrow=c(2,2))
hp = lapply(glm_list, function(x){
  hist(sapply(x$model$features, nrow),
     breaks = seq(0,ceiling(max(sapply(x$model$features, nrow))/10)*10,by=5),
     main= paste0(x$title,". m=", median(sapply(x$model$features, nrow))),
     xlab = "N features",
     ylab = "Frequency in 50 models")
})
```

```{r, include=F}
pdf(here("results", "survival", "15b_hist_features_cox_enet.pdf"), height=6, width=9)
lapply(glm_list, function(x){
  hist(sapply(x$model$features, nrow),
     breaks = seq(0,ceiling(max(sapply(x$model$features, nrow))/10)*10,by=5),
     main= x$title,
     xlab = "N features",
     ylab = "Frequency in 50 models")
})
dev.off()
```

Functions to extract recurring features in 5 x 10 xval loops

```{r}
recurring_features <- function(glm_results, anno_df = gx_annot){
  #Takes a list of fit objects where the coefficients are ensembl gene ids
  #Anno_df should be an annotation data frame that contains an ensembl_gene_id column
  
  feat = bind_rows(glm_results$features) %>%
    group_by(name) %>%
    summarise(n=n(), mean_beta = mean(value), sd_beta = sd(value)) %>%
    arrange(desc(n)) %>%
    left_join(.,gx_annot, by=c("name"="ensembl_gene_id")) %>%
    mutate(feature = if_else(is.na(gene_name), name, gene_name)) %>%
    mutate(feature_type = case_when(
      is.na(gene_type) ~ "clinical variable",
      str_detect(gene_type, "IG_") ~ "immunoglobin",
      str_detect(gene_type, "pseudogene") ~ "pseudogene",
      TRUE ~ gene_type
      )) %>%
    select(-gene_name, -gene_type) %>%
    select(feature, feature_type, everything()) %>%
    rename(ensembl_gene_id = name)
  return(feat)
}

plot_recurring_features <- function(features, label_top_n = 10, include_clinical = T){
  
  if (include_clinical == F){
    features = features %>%
      filter(feature_type != "clinical variable")
  }
  
  features = features %>% arrange(desc(n))
  
  top = head(features$feature, label_top_n)
  
  features %>%
    ggplot(aes(x = mean_beta, y = n, color = feature_type)) +
    geom_point() +
    ggrepel::geom_text_repel(aes(label=ifelse(feature %in% top, feature, "")), show.legend = F) +
    ylab("Selected as feature in n/50 models") +
    xlab("Mean beta out of 50 models")
  #geom_text(aes(label=ifelse(feature %in% top, feature, "")),
  #              position = position_nudge(y = -0.1, x = 0.1))
}
```

```{r}
glm.features = lapply(glm_list, function(x){
  list(df = recurring_features(x$model),
       title = x$title)
})
```

```{r}
feature.volc <- lapply(glm.features, function(x){
  list(clin = plot_recurring_features(x$df) +
    ggtitle(paste0("Feature selection in regularized Cox: ", x$title)),
    no_clin = plot_recurring_features(x$df, include_clinical = F) +
    ggtitle(paste0("Feature selection in regularized Cox: ", x$title)))
})

```


## Overall survival

Top 1000 variable genes:

```{r}
glm.features$os1000$df
```

Some genes go from positive to negative beta, depending on the haplotype: 

```{r}
find_feature_haplotypes <- function(x){
  x %>%
  filter(feature %in% (x %>%
           filter(duplicated(feature)) %>% pull(feature)))
}

find_feature_haplotypes(glm.features$os1000$df)
```

Volcano-like plot, with and without clinical variables:

```{r, fig.height=10, fig.width=7}
ggarrange(feature.volc$os1000$clin,
          feature.volc$os1000$no_clin,
          nrow = 2, ncol = 1)
```

Top 5000 variable genes:

```{r}
glm.features$os5000$df
```

Some genes go from positive to negative beta, depending on the haplotype: 

```{r}
find_feature_haplotypes(glm.features$os5000$df)
```

Volcano-like plot, with and without clinical variables:

```{r, fig.height=10, fig.width=7}
ggarrange(feature.volc$os5000$clin,
          feature.volc$os5000$no_clin,
          nrow = 2, ncol = 1)
```

## Distant recurrence

Top 1000 variable genes:

```{r}
glm.features$drs1000$df
```

Some genes go from positive to negative beta, depending on the haplotype: 

```{r}
find_feature_haplotypes(glm.features$drs1000$df)
```

Volcano-like plot, with and without clinical variables:

```{r, fig.height=10, fig.width=7}
ggarrange(feature.volc$drs1000$clin,
          feature.volc$drs1000$no_clin,
          nrow = 2, ncol = 1)
```

Top 5000 variable genes:

```{r}
glm.features$drs5000$df
```

Some genes go from positive to negative beta, depending on the haplotype: 

```{r}
find_feature_haplotypes(glm.features$drs5000$df)
```

Volcano-like plot, with and without clinical variables:

```{r, fig.height=10, fig.width=7}
ggarrange(feature.volc$drs5000$clin,
          feature.volc$drs5000$no_clin,
          nrow = 2, ncol = 1)
```

## Overlap selected features

```{r}
feature_overlap = lapply(glm.features, function(x) select(x$df,ensembl_gene_id,n)) %>%
  reduce(full_join, by = "ensembl_gene_id")

colnames(feature_overlap)[2:ncol(feature_overlap)] = paste0("n.", names(glm.features))
feature_overlap = feature_overlap %>%
  replace_na(list(n.os1000=0,
                  n.os5000=0,
                  n.drs1000=0,
                  n.drs5000=0))

feature_overlap$mean = rowMeans(feature_overlap[,-1])
feature_overlap$sd = rowSds(as.matrix(feature_overlap[,-1]))

feature_overlap = arrange(feature_overlap, desc(mean)) %>%
  left_join(., gx_annot, by = "ensembl_gene_id") %>%
  mutate(gene_name = if_else(is.na(gene_name), ensembl_gene_id, gene_name))
feature_overlap
```

Visualize as heatmap.
Use top 50 most frequently selected features..
Min average frequency: `r min(rowMeans(as.matrix(feature_overlap[50,2:5])))`

```{r, fig.height = 10, fig.width=7}
fmat = as.matrix(feature_overlap[1:50,2:5])
rownames(fmat) = paste(feature_overlap$gene_name[1:50],
                       str_remove(feature_overlap$ensembl_gene_id[1:50],"NSG00000"),
                       sep=":")

pheatmap(fmat, display_numbers = T, number_format = "%0.f")
```

# Predictions

Paraphrased from [this post](https://stats.stackexchange.com/questions/388770/cox-model-with-lasso-using-one-dataset-and-predicting-in-a-different-dataset):

With cox models, type = "link" gives the linear predictor. 
(Recap: The linear predictor is a linear sum of the effects of one or more explanatory variables). 
The right-hand side of the equation is called the linear structure. 
Type = response is essentially the exponential of the linear predictor, giving a relative risk of survival outcome.
It's relative between samples, so if you want to get survival probability, a baseline measure must be calculated (comparable to intercept).

However, the Cox model itself cannot give you the S0, you need another method to estimate the S0, for example, fitting your covariate with beta into a coxph model with initial covariates and then estimate baseline with basehaz. 
See also: [Frailtypack](https://cran.r-project.org/web/packages/frailtypack/index.html) (R package)

Create a separate column for each full prediction set.

```{r}
relrisk.df = lapply(glm_list, function(x) {
  x$model$relrisk %>%
    set_names(paste0("fitted_relrisk_", 1:length(.))) %>%
    bind_rows(.id = "n_pred") %>%
    spread(key=n_pred, value=fitted_relative_risk)
  
})
head(relrisk.df[[1]])

```

Because the risk is relative between samples, we take the Z score centered on column

```{r}
z.relrisk = lapply(relrisk.df, function(x){
  y = as.data.frame(scale(x[,-1]))
  
  rownames(y) = x$samples
  
  y = rownames_to_column(y, "sample_name") %>%
    gather(key = model, value="rel.risk", -sample_name)
  
  return(y)
})

head(z.relrisk[[1]])
```

```{r}
relplot.df = lapply(z.relrisk, function(x) {
  coxdata %>%
    #rownames_to_column("sample_name") %>%
    #filter(metastasis_at_diagnosis != 1) %>% #Only for drs
    select(sample_name, months_overall_survival, overall_survival,
                     months_to_drs, distant_recurrence, PPBC) %>%
    mutate(death = if_else(overall_survival==1, T, F),
           distant_recurrence = as.factor(distant_recurrence)) %>%
    left_join(., x, by = "sample_name")
})

relplot.df[[1]] %>% head(10)
```

## Plot relative risk

Plotting predicted risk vs reality shows a fairly poor performance.

```{r, fig.width=10, fig.height=8}
set.seed(123)
se <- function(x) sd(x)/sqrt(length(x))
lm_eqn <- function(df){
    m <- lm(mean.rel.risk ~ months_overall_survival, df);
    #eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
    #     list(a = format(unname(coef(m)[1]), digits = 2),
    #          b = format(unname(coef(m)[2]), digits = 2),
    #         r2 = format(summary(m)$r.squared, digits = 3)))
    r2 = format(summary(m)$r.squared, digits = 2)
    #as.character(as.expression(eq));
    as.character(r2);
}

gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

relplots = lapply(list(relplot.df$os1000, relplot.df$os5000), function(x){
  erplot.df = x %>%
    group_by(sample_name, months_overall_survival,death, PPBC) %>%
    summarise(mean.rel.risk = mean(rel.risk), se = se(rel.risk)) 

    R2.death = lm_eqn(erplot.df[erplot.df$death==1,])
    R2.surv = lm_eqn(erplot.df[erplot.df$death==0,])

    cols = gg_color_hue(2)

    erplot.df %>%
      ggplot(aes(x = months_overall_survival, y = mean.rel.risk, color=death)) + #shape=study_group 
      geom_point(size=3) +
      geom_errorbar(aes(ymin=mean.rel.risk-se, ymax=mean.rel.risk+se), width=.2,
                    position=position_dodge(.9)) +
      ggtitle("Relationship between relative risk and survival") +
      geom_smooth(se=F, method="loess") +
      #geom_text(x = 10, y = 0, label = paste("R2:", R2.surv,sep="\n"), parse = TRUE, color = cols[1], show.legend = F) +
      #geom_text(x = 10, y = 2.0, label = paste("R2:", R2.death,sep="\n"), parse = TRUE, color = cols[2],show.legend = F) +
      theme_minimal() +
      xlab("")#xlab("Months follow-up")
})

lm_eqn <- function(df){
    m <- lm(mean.rel.risk ~ months_to_drs, df);
    #eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
    #     list(a = format(unname(coef(m)[1]), digits = 2),
    #          b = format(unname(coef(m)[2]), digits = 2),
    #         r2 = format(summary(m)$r.squared, digits = 3)))
    r2 = format(summary(m)$r.squared, digits = 2)
    #as.character(as.expression(eq));
    as.character(r2);
}

relplots = append(relplots,
lapply(list(relplot.df$drs1000, relplot.df$drs5000), function(x){
  erplot.df = x %>%
    group_by(sample_name, months_to_drs, distant_recurrence, PPBC) %>%
    summarise(mean.rel.risk = mean(rel.risk), se = se(rel.risk)) 

    R2.dr = lm_eqn(erplot.df[erplot.df$distant_recurrence==1,])
    R2.none = lm_eqn(erplot.df[erplot.df$distant_recurrence==0,])

    cols = gg_color_hue(2)

    erplot.df %>%
      ggplot(aes(x = months_to_drs, y = mean.rel.risk, color=distant_recurrence)) + #shape=study_group 
      geom_point(size=3) +
      geom_errorbar(aes(ymin=mean.rel.risk-se, ymax=mean.rel.risk+se), width=.2,
                    position=position_dodge(.9)) +
      ggtitle("Relationship between relative risk and survival") +
      geom_smooth(se=F, method="loess") +
      #geom_text(x = 10, y = 0, label = paste("R2:", R2.surv,sep="\n"), parse = TRUE, color = cols[1], show.legend = F) +
      #geom_text(x = 10, y = 2.0, label = paste("R2:", R2.death,sep="\n"), parse = TRUE, color = cols[2],show.legend = F) +
      theme_minimal() +
      labs(color = "dr") +
      xlab("")#xlab("Months follow-up")
}))


#names(relplots)
ggarrange(plotlist = list(
  relplots[[1]] +
    ggtitle("os1000"),
  relplots[[2]] +
    ggtitle("os5000"),
  relplots[[3]] +
    ggtitle("drs1000"),
  relplots[[4]] +
    ggtitle("drs5000")
  ), nrow = 2, ncol = 2
) %>%
  annotate_figure(top = "Relationship between relative risk and outcome",
                  bottom = "Months follow-up")

```

```{r}
ggsave(here("results", "survival", "15b_cox_predictions.pdf"), height=6, width = 9)
```

## Correlation prediction vs outcome

Pearson correlation:

```{r}
pears_cor = 
tibble(
  cor = c(
    unlist(lapply(list(relplot.df$os1000, relplot.df$os5000), function(x){
      signif(cor(x$rel.risk, x$overall_survival,
          use="complete.obs", method = "pearson"), 2)
    })),
    unlist(lapply(list(relplot.df$drs1000, relplot.df$drs5000), function(x){
      signif(cor(x$rel.risk, as.numeric(as.character(x$distant_recurrence)),
          use = "complete.obs", method = "pearson"),2)
    }))
  ),
  outcome = c(rep("overall survival",2), rep("distant recurrence",2)),
  input = c("top 1000 var", "top 5000 var","top 1000 var","top 5000 var"),
  method = rep("Pearson", 4),

)

pears_cor
```

Spearman correlation:

```{r}
spear_cor =
tibble(
  cor = c(
    unlist(lapply(list(relplot.df$os1000, relplot.df$os5000), function(x){
      signif(cor.test(x$rel.risk, x$overall_survival,
          use="complete.obs", method = "spearman")$estimate,2)
    })),
    unlist(lapply(list(relplot.df$drs1000, relplot.df$drs5000), function(x){
      signif(cor.test(x$rel.risk, as.numeric(as.character(x$distant_recurrence)),
          use = "complete.obs", method = "spearman")$estimate,2)
    }))
  ),
  outcome = c(rep("overall survival",2), rep("distant recurrence",2)),
  input = c("top 1000 var", "top 5000 var","top 1000 var","top 5000 var"),
  method = rep("Spearman", 4),

)

spear_cor
```

## P val correlation

The p values that comes out of cor.test are suspiciously small, because every iteration of the loop is treated like new samples.
Instead, we get a [t statistic based on sample size](https://towardsdatascience.com/eveything-you-need-to-know-about-interpreting-correlations-2c485841c0b8).

t = (r * sqrt(n-2))/(sqrt(1 - r^2))

Where n is sample size and r is correlation coeffcient.
Bear in mind that the sample size for drs may not be equivalent to os, since drs models may not have metastasis at diagnosis.

Refreshed our memory on how to get a p value from a t stat [here](https://www.cyclismo.org/tutorial/R/pValues.html)

2*pt(-abs(t),df=n-1)

Where n is sample size and t is t statistic.

```{r}
tstat <- function(r, n){
  (r * sqrt(n-2))/(sqrt(1 - r^2))
}

p_from_t <- function(ts, n){
  2*pt(-abs(ts),df=n-2)
}

spear_cor = spear_cor %>%
  mutate(n = unlist(lapply(list(var1000,var5000,
                                var1000.drs, var5000.drs), nrow))) %>%
  rowwise() %>%
  mutate(tstat = tstat(cor, n)) %>%
  mutate(pval = signif(p_from_t(tstat,n), 2)) %>%
  select(cor, pval, everything())

spear_cor
```


# Overlap with previous survival

For survival analyses, a global minimum fdr threshold of 0.2.
Ignore the involution-only genewise models and the interaction modesl, as they had almost no hits.
For diffex, the usual cutoff. Use only those comparisons which are interesting for involution.
For elastic net Cox, use only those features that are selected in at least 25/50 models.

```{r}
overlap = lapply(gw_surv[!str_detect(names(gw_surv), "inv_")],
                 function(x){
  as.character(filter(x, fdr <= 0.2)$ensembl_gene_id)
})


overlap = append(overlap, lapply(glm.features, function(x){
  filter(x$df, !feature_type == "clinical variable") %>%
    filter(n >= 25) %>% pull(ensembl_gene_id)
  
})
)


lapply(overlap, length)

```

```{r, fig.width=8, fig.height=7}
upset(fromList(overlap), order.by = "freq", #empty.intersections = "on",
      nsets = length(overlap), 
      set_size.show = TRUE, mainbar.y.label = "Overlap survival analyses",
      sets.bar.color = "blue", main.bar.color = "black",
      #set_size.scale_max = 500,
      sets.x.label = "N genes")
```

What are these few genes that overlap almost everywhere?

```{r}
#crossprod(table(stack(overlap)))
m = addmargins(table(stack(overlap)))
mt = m %>% unclass() %>% as.data.frame() %>%
  rownames_to_column("ensembl_gene_id") %>%
  arrange(desc(Sum)) %>%
  filter(Sum >= 4) %>%
  filter(str_detect(ensembl_gene_id, "ENSG")) %>%
  left_join(., gx_annot, by = "ensembl_gene_id") %>%
  select(gene_name, Sum, everything())
mt$enetsum = rowSums(mt[,8:11])

mt = mt %>% select(gene_name, Sum, enetsum, everything())
mt
```

Most of those are from overlap between the genewise model.
Which are also selected as features in elestic net cox?

```{r}
filter(mt, enetsum > 0)
```


# Overlap with diffex

```{r}
diffex_comps = c("inv_vs_nonprbc", "inv_vs_rest", "inv_vs_prbc")
overlap = lapply(diffex_list[names(diffex_list) %in% diffex_comps],
         function(x){
           as.character(filter(x, padj <= 0.05 & abs(log2FoldChange) > 0.5)$ensembl_gene_id)
         })

overlap = append(overlap, lapply(glm.features, function(x){
  filter(x$df, !feature_type == "clinical variable") %>%
    filter(n >= 25) %>% pull(ensembl_gene_id)
  
})
)

lapply(overlap, length)
```

```{r, fig.width=8, fig.height=7}
upset(fromList(overlap), order.by = "freq", #empty.intersections = "on",
      nsets = length(overlap), 
      set_size.show = TRUE, mainbar.y.label = "Overlap elastic cox and diffex",
      sets.bar.color = "blue", main.bar.color = "black",
      #set_size.scale_max = 1200,
      sets.x.label = "N genes")
```

# Save data

```{r}
openxlsx::write.xlsx(lapply(glm.features, function(x){x[[1]]}),
                     file = here("results", "survival", "15b_inv_elastic_cox_features.xlsx"))
write_csv(spear_cor, here("results/survival/15b_enetcox_pvals.csv"))
```

```{r}
sessionInfo()
```

